[ {
  "uuid" : "ade954f4-0376-424b-9010-e5dc89649d52",
  "id" : 2042,
  "name" : "Distributed - Activities pending",
  "query" : "'use strict';\n({params, imports}) => {\n    const _= imports.lodash;\n    const isDistributionDone = (individual) => {\n        const distributionWithoutactivities = individual.getEncounters()\n            .filter((enc) => enc.encounterType.name === 'Distribution')\n            .filter((enc) => _.isEmpty(enc.getObservationValue('Activities Done') ));\n        if (distributionWithoutactivities.length > 0){     \n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    let Activities = params.db.objects('Individual')\n        .filter((individual) => individual.voided === false && individual.subjectType.name === 'Demand' && isDistributionDone(individual));\n    return _.orderBy(Activities, ind => ind.registrationDate, 'desc');\n};",
  "description" : "Demands with Distribution present with no values for \"Activities done\"",
  "color" : "#ebc944",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "dd871765-c5ca-4696-8718-2d6af9ae56a3",
  "id" : 2040,
  "name" : "Distributions done",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({params, imports}) => {\n    const _= imports.lodash;\n    const moment = imports.moment;\n        \n    let Distributions = params.db.objects('Individual').filtered('subjectType.name = \"Distribution\" AND voided = false');\n     \n     if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        let accountFilter =  params.ruleInput.filter(rule => rule.type === \"Concept\");\n        let registrationDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n                \n        \n        if(registrationDateFilter.length>0 && registrationDateFilter[0].filterValue){\n            let startDate = moment(registrationDateFilter[0].filterValue.minValue).startOf('day').toDate();\n            let endDate = moment(registrationDateFilter[0].filterValue.maxValue).startOf('day').toDate();                                   \n            \n            Distributions = Distributions.filtered(`registrationDate >= $0 AND registrationDate <= $1`,startDate,endDate);\n        }    \n\n\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            let addressValue = addressFilter[0].filterValue.filter((add) => add.type == \"Village\").map(add => add.uuid);\n\n            if (addressValue.length > 0) {\n                let addressValueString = \"{\\\"\" + addressValue.join(\"\\\", \\\"\") + \"\\\"}\";\n                Distributions = Distributions.filtered(`lowestAddressLevel.uuid in ${addressValueString}`);\n            }\n        }\n        \n        if(accountFilter.length > 0  && accountFilter[0].filterValue){\n            let accountName = accountFilter[0].filterValue.toLowerCase().trim();\n            Distributions = Distributions.filter(ind => {\n                let acName = ind.getObservationReadableValue(\"2978117c-a297-4171-99c6-23c3522ca0f8\");\n                return acName && acName.toLowerCase().includes(accountName)\n            });\n        }\n    }     \n\n\n                 \n   return _.orderBy(Distributions, ind => ind.registrationDate, 'desc');\n};",
  "description" : "",
  "color" : "#92c5d3",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "65483e90-e323-4096-9e99-c3009800a1cc",
  "id" : 2037,
  "name" : "Dispatches to be received",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({params, imports}) => {\n    const _= imports.lodash;\n    const moment = imports.moment;\n    \n    const isOpenDispatch = (individual) => {\n        const dispactReceiptEncounter = individual.getEncounters()\n            .filter((enc) => enc.encounterType.name === 'Dispatch receipt' && (!enc.voided));\n        if (dispactReceiptEncounter.length < 1 ){\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n\n    let inds = params.db.objects('Individual').filtered('subjectType.name = \"Dispatch\" AND voided = false');\n  \n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        let accountFilter =  params.ruleInput.filter(rule => rule.type === \"Concept\");\n        let registrationDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n                \n        \n        if(registrationDateFilter.length>0 && registrationDateFilter[0].filterValue){\n            let startDate = moment(registrationDateFilter[0].filterValue.minValue).startOf('day').toDate();\n            let endDate = moment(registrationDateFilter[0].filterValue.maxValue).startOf('day').toDate();                                   \n            \n            inds = inds.filtered(`registrationDate >= $0 and  registrationDate <= $1`,startDate,endDate);\n        }\n        \n\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            let addressValue = addressFilter[0].filterValue.filter((add) => add.type == \"District\").map(add => add.uuid);\n\n            if (addressValue.length > 0) {\n                let addressValueString = \"{\\\"\" + addressValue.join(\"\\\", \\\"\") + \"\\\"}\";\n                inds = inds.filtered(`lowestAddressLevel.uuid in ${addressValueString}`);\n            }\n        }\n        \n        if(accountFilter.length > 0  && accountFilter[0].filterValue){\n            let accountName = accountFilter[0].filterValue.toLowerCase().trim();\n            inds = inds.filter(ind => {\n                let acName = ind.getObservationReadableValue(\"2978117c-a297-4171-99c6-23c3522ca0f8\");\n                return acName && acName.toLowerCase().includes(accountName)\n            });\n        }\n       \n    }     \n        \n\n    inds = inds.filter(individual => {\n        let val = individual.getObservationValue('b7e82e4d-ee4c-4a6e-bb98-7a0b4eb21392');\n        return isOpenDispatch(individual) && val && val != 'Reached'\n    })\n          \n    return _.orderBy(inds, ind => ind.registrationDate, 'desc')\n};",
  "description" : "Total dispatch without having a dispatch receipt",
  "color" : "#f58b4c",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "82468ce4-0ef1-4aed-89bd-a6985ad55e89",
  "id" : 2043,
  "name" : "Distributions without activities",
  "query" : "'use strict';\n({params, imports}) => {\n  const _= imports.lodash;\n  const moment = imports.moment;  \n  const Distributions = params.db.objects('Individual').filtered('subjectType.name = \"Distribution\" AND voided = false');\n   \n    \n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        let accountFilter =  params.ruleInput.filter(rule => rule.type === \"Concept\");\n        let registrationDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n                \n        \n        if(registrationDateFilter.length>0 && registrationDateFilter[0].filterValue){\n            let startDate = moment(registrationDateFilter[0].filterValue.minValue).startOf('day').toDate();\n            let endDate = moment(registrationDateFilter[0].filterValue.maxValue).startOf('day').toDate();                                   \n            \n            Distributions = Distributions.filtered(`registrationDate >= $0 AND registrationDate <= $1`,startDate,endDate);\n        }            \n\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            let addressValue = addressFilter[0].filterValue.filter((add) => add.type == \"Village\").map(add => add.uuid);\n\n            if (addressValue.length > 0) {\n                let addressValueString = \"{\\\"\" + addressValue.join(\"\\\", \\\"\") + \"\\\"}\";\n                Distributions = Distributions.filtered(`lowestAddressLevel.uuid in ${addressValueString}`);\n            }\n        }\n        \n        if(accountFilter.length > 0  && accountFilter[0].filterValue){\n            let accountName = accountFilter[0].filterValue.toLowerCase().trim();\n            Distributions = Distributions.filter(ind => {\n                let acName = ind.getObservationReadableValue(\"2978117c-a297-4171-99c6-23c3522ca0f8\");\n                return acName && acName.toLowerCase().includes(accountName)\n            });\n        }\n    }     \n    \n\n    Distributions = Distributions.filter((individual) => {\n        const observationValue = individual.getObservationReadableValue('3fb0d2c5-0210-49be-a31c-a6a134131af3');\n        if (!observationValue || _.isEmpty(observationValue) || _.isEmpty(observationValue[0])) {\n          return true;\n        }\n        return false;\n      });\n  \n\n  return _.orderBy(Distributions, ind => ind.registrationDate, 'desc');\n  return Distributions;\n};",
  "description" : "",
  "color" : "#3d4caf",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "e5da553a-5f07-4cec-aedb-55e3f1fd11aa",
  "id" : 2035,
  "name" : "Demands to be dispatched",
  "query" : "'use strict';\n({params, imports}) => {\n    const _ = imports.lodash;\n    const moment = imports.moment;\n    \n    let demands = params.db.objects('Individual').filtered('subjectType.name = \"Demand\" AND voided = false');\n\n           \n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        let accountFilter =  params.ruleInput.filter(rule => rule.type === \"Concept\");\n        let registrationDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n               \n        \n        if(registrationDateFilter.length>0 && registrationDateFilter[0].filterValue){\n            let startDate = moment(registrationDateFilter[0].filterValue.minValue).startOf('day').toDate();\n            let endDate = moment(registrationDateFilter[0].filterValue.maxValue).startOf('day').toDate();            \n            \n            demands = demands.filtered(`registrationDate >= $0 AND registrationDate <= $1`,startDate,endDate);\n        }\n        \n        \n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n           \n            let addressValue = addressFilter[0].filterValue.filter((add) => add.type == \"District\").map(add => add.uuid);\n\n            if (addressValue.length > 0) {\n                let addressValueString = \"{\\\"\" + addressValue.join(\"\\\", \\\"\") + \"\\\"}\";\n                demands = demands.filtered(`lowestAddressLevel.uuid in ${addressValueString}`);\n            }\n        }\n        \n        if(accountFilter.length > 0  && accountFilter[0].filterValue){\n            let accountName = accountFilter[0].filterValue.toLowerCase().trim();\n            demands = demands.filter(ind => {\n                let acName = ind.getObservationReadableValue(\"2978117c-a297-4171-99c6-23c3522ca0f8\");\n                return acName && acName.toLowerCase().includes(accountName)\n            });\n        }\n        \n       \n    }                \n\n    demands = demands.filter(individual => individual.getObservationValue('82970f35-d1aa-4e05-95fa-19b71617db0d') !== 'Dispatched');\n    return _.orderBy(demands, ind => ind.registrationDate, 'desc');\n};",
  "description" : "Total Demands with no Dispatch",
  "color" : "#1496bb",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "979e3934-6533-4ad1-a3a5-ca77fe5ab742",
  "id" : 2038,
  "name" : "Received Dispatches",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({params, imports}) => {\n    const _= imports.lodash;\n    const moment = imports.moment;\n        \n    const dispatchesReceived = (individual) => {\n        const dispatchEncounter = individual.getEncounters()\n            .filter((enc) => enc.encounterType.name === 'Dispatch receipt' && enc.encounterDateTime != null);\n        if (dispatchEncounter.length > 0) {\n            return true;\n        } \n        else {\n            return false;\n        }\n    };\n    \n    let inds = params.db.objects('Individual').filtered('subjectType.name = \"Dispatch\" AND voided = false');\n    \n\n\n   if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        let accountFilter =  params.ruleInput.filter(rule => rule.type === \"Concept\");\n        let registrationDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n                \n        \n        if(registrationDateFilter.length>0 && registrationDateFilter[0].filterValue){\n            let startDate = moment(registrationDateFilter[0].filterValue.minValue).startOf('day').toDate();\n            let endDate = moment(registrationDateFilter[0].filterValue.maxValue).startOf('day').toDate();                                   \n            \n            inds = inds.filtered(`registrationDate >= $0 AND registrationDate <= $1`,startDate,endDate);\n        }        \n\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            let addressValue = addressFilter[0].filterValue.filter((add) => add.type == \"District\").map(add => add.uuid);\n\n            if (addressValue.length > 0) {\n                let addressValueString = \"{\\\"\" + addressValue.join(\"\\\", \\\"\") + \"\\\"}\";\n                inds = inds.filtered(`lowestAddressLevel.uuid in ${addressValueString}`);\n            }\n        }\n        \n        if(accountFilter.length > 0  && accountFilter[0].filterValue){\n            let accountName = accountFilter[0].filterValue.toLowerCase().trim();\n            inds = inds.filter(ind => {\n                let acName = ind.getObservationReadableValue(\"2978117c-a297-4171-99c6-23c3522ca0f8\");\n                return acName && acName.toLowerCase().includes(accountName)\n            });\n        }\n        \n       \n    }\n\n    inds = inds.filter((individual)=> individual.getObservationValue('b7e82e4d-ee4c-4a6e-bb98-7a0b4eb21392') === 'Reached'\n    || dispatchesReceived(individual));\n    \n          \n    return _.orderBy(inds, ind => ind.registrationDate, 'desc')\n};",
  "description" : "Showing the count of demands which have the Dispatch and Dispatch receipt form.",
  "color" : "#a3b86c",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "934b2405-61c6-4576-8ce0-b9c8587215ac",
  "id" : 2034,
  "name" : "Activities not linked to distributions",
  "query" : "\n\n'use strict';\n({params, imports}) => {\n    const _= imports.lodash;\n    const moment = imports.moment;     \n    let addressQuery = '';\n    let accountQuery = '';\n    let startDate = null;  \n    let endDate = null;\n\n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        let accountFilter = params.ruleInput.filter(rule => rule.type === \"Concept\");\n        let registrationDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n                \n        \n        if(registrationDateFilter.length>0 && registrationDateFilter[0].filterValue){\n            startDate = moment(registrationDateFilter[0].filterValue.minValue).startOf('day').toDate();\n            endDate = moment(registrationDateFilter[0].filterValue.maxValue).startOf('day').toDate();                                   \n            \n        }                \n\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            let addressValue = addressFilter[0].filterValue.filter((add) => add.type == \"Village\").map(add => add.uuid);\n\n            if (addressValue.length > 0) {\n                addressQuery = \"lowestAddressLevel.uuid in {\\\"\" + addressValue.join(\"\\\", \\\"\") + \"\\\"}\";\n            }\n        }\n\n        if (accountFilter.length > 0 && accountFilter[0].filterValue) {\n            let accountName = accountFilter[0].filterValue.toLowerCase().trim();\n            accountQuery = ind => {\n                let acName = ind.getObservationReadableValue(\"2978117c-a297-4171-99c6-23c3522ca0f8\");\n                return acName && acName.toLowerCase().includes(accountName)\n            };\n        }\n    }\n\n    let allDistributions = params.db.objects('Individual')\n        .filtered('voided = false and subjectType.name = \"Distribution\"');\n\n    const uuidsOfAllLinkedActivitiesSet = new Set();    \n\n    allDistributions\n        .filter(()=>true)\n        .flatMap((individual) => individual.getObservationReadableValue('3fb0d2c5-0210-49be-a31c-a6a134131af3'))  // activity details\n        .flatMap(arr => arr ? arr.map(obj => obj[\"Activities Done\"]) : []) //question group\n        .forEach(uuid => uuid && uuidsOfAllLinkedActivitiesSet.add(uuid) );\n\n    let allActivities = params.db.objects('Individual')\n        .filtered('voided = false and subjectType.name = \"Activity\"');\n        \n    if(startDate!=null && endDate!=null){\n        allActivities = allActivities.filtered(`registrationDate >= $0 AND registrationDate <= $1`,startDate,endDate);    \n    }         \n\n    if (addressQuery.length > 0) {\n        allActivities = allActivities.filtered(addressQuery);\n    }\n    if (accountQuery !== '') {\n        allActivities = allActivities.filter(accountQuery);\n    }\n    let arr = allActivities.filter(i => !uuidsOfAllLinkedActivitiesSet.has(i.uuid));\n    \n    let allLinkedActivities = () => {\n        return _.orderBy(arr, ind => ind.registrationDate, 'desc');\n    };\n\n    return{primaryValue:arr.length, lineListFunction : allLinkedActivities};\n    // return _.orderBy(allLinkedActivities, ind => ind.registrationDate, 'desc');\n};\n\n",
  "description" : "",
  "color" : "#3f7229",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "1a030630-8541-4e81-9f9a-7912412b723c",
  "id" : 2033,
  "name" : "Activities linked to distribution",
  "query" : "'use strict';\n({params, imports}) => {\n    const _= imports.lodash;\n    const moment = imports.moment;    \n    let addressQuery = '';\n    let accountQuery = '';\n    let startDate = null;\n    let endDate = null;\n    \n\n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        let accountFilter = params.ruleInput.filter(rule => rule.type === \"Concept\");\n        let registrationDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n                \n        \n        if(registrationDateFilter.length>0 && registrationDateFilter[0].filterValue){\n            startDate = moment(registrationDateFilter[0].filterValue.minValue).startOf('day').toDate();\n            endDate = moment(registrationDateFilter[0].filterValue.maxValue).startOf('day').toDate();            \n                       \n            \n        }            \n\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            let addressValue = addressFilter[0].filterValue.filter((add) => add.type == \"Village\").map(add => add.uuid);\n\n            if (addressValue.length > 0) {\n                addressQuery = \"lowestAddressLevel.uuid in {\\\"\" + addressValue.join(\"\\\", \\\"\") + \"\\\"}\";\n            }\n        }\n\n        if (accountFilter.length > 0 && accountFilter[0].filterValue) {\n            let accountName = accountFilter[0].filterValue.toLowerCase().trim();\n            accountQuery = ind => {\n                let acName = ind.getObservationReadableValue(\"2978117c-a297-4171-99c6-23c3522ca0f8\");\n                return acName && acName.toLowerCase().includes(accountName)\n            };\n        }\n    }\n\n    let allDistributions = params.db.objects('Individual')\n        .filtered('voided = false and subjectType.name = \"Distribution\"');\n\n    const uuidsOfAllLinkedActivitiesSet = new Set();    \n\n    allDistributions\n        .filter(()=>true)\n        .flatMap((individual) => individual.getObservationReadableValue('3fb0d2c5-0210-49be-a31c-a6a134131af3'))  // activity details\n        .flatMap(arr => arr ? arr.map(obj => obj[\"Activities Done\"]) : []) //question group\n        .forEach(uuid => uuid && uuidsOfAllLinkedActivitiesSet.add(uuid) );\n\n    let allActivities = params.db.objects('Individual')\n        .filtered('voided = false and subjectType.name = \"Activity\"');\n        \n    if(startDate!=null && endDate!=null){\n        allActivities = allActivities.filtered(`registrationDate >= $0 AND registrationDate <= $1`,startDate,endDate);    \n    }    \n\n    if (addressQuery.length > 0) {\n        allActivities = allActivities.filtered(addressQuery);\n    }\n    if (accountQuery !== '') {\n        allActivities = allActivities.filter(accountQuery);\n    }\n    let arr = allActivities.filter(i => uuidsOfAllLinkedActivitiesSet.has(i.uuid));\n    \n    let allLinkedActivities = () => {\n        return _.orderBy(arr, ind => ind.registrationDate, 'desc');\n    };\n\n    return{primaryValue:arr.length, lineListFunction : allLinkedActivities};\n    // return _.orderBy(allLinkedActivities, ind => ind.registrationDate, 'desc');\n};\n",
  "description" : "",
  "color" : "#d44f4f",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "6867dca0-474d-49d8-a30c-19510364e286",
  "id" : 2041,
  "name" : "Activity Done - Distribution pending",
  "query" : "'use strict';\n({params, imports}) => {\n    const isDistributionPending = (individual) => {\n        const activities = individual.getEncounters()\n            .filter((enc) => enc.encounterType.name === 'Activity');\n        const distros = individual.getEncounters()\n            .filter((enc) => enc.encounterType.name === 'Distribution');\n       return (activities.length > 0 && distros.length === 0);     \n    };\n    let Activities = params.db.objects('Individual')\n        .filter((individual) => individual.voided === false && individual.subjectType.name === 'Demand' && isDistributionPending(individual));\n    return _.orderBy(Activities, ind => ind.registrationDate, 'desc');\n};",
  "description" : "Are Distributions pending for this Demand",
  "color" : "#c300ff",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "88484e51-e81c-4859-b6a9-7f0e4c55e17c",
  "id" : 2031,
  "name" : "Pending Distribution - New",
  "query" : "'use strict';\n({params, imports}) => {\n    const _ = imports.lodash\n    const distributionComplete = (demand) => {\n        const calculateSumOfObservationValuesRecieved = (materialTypes) => {\n            return demand.getEncounters()\n                .filter((enc) => enc.encounterType.name === 'Dispatch receipt')\n                .flatMap((enc) => enc.getObservationValue('5dfb2f28-b866-4442-be01-0ed451c6aad9'))\n                .filter(obs => !_.isNil(obs))\n                .map((obs) => obs.getReadableValue())\n                .map((keyValues) => {\n                    const isQuantityMatching = _.get(_.find(keyValues, (kv) => kv['Quantity matching']), 'Quantity matching');\n                    const matchingQuantity = _.get(_.find(keyValues, (kv) => kv['Quantity (Dispatched)']), 'Quantity (Dispatched)') || 0;\n                    const notMatchingQuantity =\n                        _.get(_.find(keyValues, (kv) => kv['Quantity']), 'Quantity') || 0;\n                    const typeOfMaterial = _.get(_.find(keyValues, (kv) => kv['Type Of Material']), 'Type Of Material');\n               //     console.log('typeOfMaterial',typeOfMaterial);\n\n                    if (isQuantityMatching === 'Yes' && materialTypes.includes(typeOfMaterial))\n                        return matchingQuantity;\n                    else if (isQuantityMatching === 'No' && materialTypes.includes(typeOfMaterial))\n                        return notMatchingQuantity;\n                    else return 0;\n                })\n                .reduce((a, b) => a + b, 0);\n        };\n\n        const calculateSumOfObservationValuesDistributed = (materialTypes) => {\n            return demand.getEncounters()\n                .filter((enc) => enc.encounterType.name === 'Distribution')\n                .flatMap((enc) => enc.getObservationValue('3093c0f1-5e3f-47eb-92ed-0067b41b6f9c'))\n                .map((obs) => obs.getReadableValue())\n                .map((keyValues) => {\n                    const quantityNumber = _.get(_.find(keyValues, (kv) => kv['Quantity']), 'Quantity') || 0;\n                    const typeOfMaterial = _.get(_.find(keyValues, (kv) => kv['Type Of Material']), 'Type Of Material');\n                    return materialTypes.includes(typeOfMaterial) ? quantityNumber : 0;\n                })\n                .reduce((a, b) => a + b, 0);\n        };\n\n        return calculateSumOfObservationValuesRecieved(['Kit']) === calculateSumOfObservationValuesDistributed(['Kit'])\n            && calculateSumOfObservationValuesRecieved(['Contributed item']) === calculateSumOfObservationValuesDistributed(['Contributed item'])\n            && calculateSumOfObservationValuesRecieved(['Purchased item', 'Contributed track', 'Goonj product', 'High Value Material']) === calculateSumOfObservationValuesDistributed(['Purchased item', 'Contributed track', 'Goonj product', 'High Value Material'])\n    };\n    \n    return params.db.objects('Individual')\n        .filter((demand) => demand.voided === false && !distributionComplete(demand))\n};\n",
  "description" : "",
  "color" : "#ff0000",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "6085c2f4-52e7-4b08-85b6-d6b2612b4cf5",
  "id" : 4639,
  "name" : "Scheduled visits",
  "color" : "#388e3c",
  "nested" : false,
  "count" : 1,
  "standardReportCardType" : "27020b32-c21b-43a4-81bd-7b88ad3a6ef0",
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "85ce7239-e8b5-4e57-b07d-66c18cee47b2",
  "id" : 4640,
  "name" : "Overdue visits",
  "color" : "#d32f2f",
  "nested" : false,
  "count" : 1,
  "standardReportCardType" : "9f88bee5-2ab9-4ac4-ae19-d07e9715bdb5",
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "a1673f8a-c394-4bcf-8b6f-63d83a5443e2",
  "id" : 4641,
  "name" : "Total",
  "color" : "#ffffff",
  "nested" : false,
  "count" : 1,
  "standardReportCardType" : "1fbcadf3-bf1a-439e-9e13-24adddfbf6c0",
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "f366f35a-5c4f-4ff7-b510-2dc9f5f88847",
  "id" : 4642,
  "name" : "Recent registrations",
  "color" : "#ffffff",
  "nested" : false,
  "count" : 1,
  "standardReportCardType" : "88a7514c-48c0-4d5d-a421-d074e43bb36c",
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "standardReportCardInputRecentDuration" : "{\"value\":\"1\",\"unit\":\"days\"}",
  "voided" : false
}, {
  "uuid" : "e1036b69-df46-4351-9916-10cd4cfcb6bd",
  "id" : 4643,
  "name" : "Recent enrolments",
  "color" : "#ffffff",
  "nested" : false,
  "count" : 1,
  "standardReportCardType" : "a5efc04c-317a-4823-a203-e62603454a65",
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "standardReportCardInputRecentDuration" : "{\"value\":\"1\",\"unit\":\"days\"}",
  "voided" : false
}, {
  "uuid" : "dd961ee1-9d4e-4ec9-99f0-99b36672be7c",
  "id" : 4644,
  "name" : "Recent visits",
  "color" : "#ffffff",
  "nested" : false,
  "count" : 1,
  "standardReportCardType" : "77b5b3fa-de35-4f24-996b-2842492ea6e0",
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "standardReportCardInputRecentDuration" : "{\"value\":\"1\",\"unit\":\"days\"}",
  "voided" : false
}, {
  "uuid" : "100c4017-2fa9-4d4d-9d0f-bf91ade87fc4",
  "id" : 5191,
  "name" : "All Registered Villages",
  "query" : "'use strict';\n({params, imports}) => {\n    const _= imports.lodash;\n    const moment = imports.moment;\n    \n    let inds = params.db.objects('Individual').filtered(`subjectType.name = \"Village\" AND voided = false`);\n    \n    if (params.ruleInput) {\n        //Account filter is not applicable for Village SubjectType\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        let registrationDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n                \n        \n        if(registrationDateFilter.length>0 && registrationDateFilter[0].filterValue){\n            let startDate = moment(registrationDateFilter[0].filterValue.minValue).startOf('day').toDate();\n            let endDate = moment(registrationDateFilter[0].filterValue.maxValue).endOf('day').toDate();                                   \n            \n            inds = inds.filtered(`registrationDate >= $0 AND registrationDate <= $1`,startDate,endDate);\n        }    \n\n\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            let addressValue = addressFilter[0].filterValue.filter((add) => add.type == \"Village\").map(add => add.uuid);\n\n            if (addressValue.length > 0) {\n                let addressValueString = \"{\\\"\" + addressValue.join(\"\\\", \\\"\") + \"\\\"}\";\n                inds = inds.filtered(`lowestAddressLevel.uuid in ${addressValueString}`);\n            }\n        }\n    }   \n    \n    return _.orderBy(inds, ind => ind.registrationDate, 'desc');\n};\n",
  "description" : "",
  "color" : "#09a2f8",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "a96daf6a-09a7-43a7-ab4d-32c4b3335678",
  "id" : 4645,
  "name" : "Village Assessment Completed",
  "query" : "({params, imports}) => {\n    const _ = imports.lodash;\n    const moment = imports.moment;\n    const LOCATION_ASSESSMENT_CONCEPT = '348a795a-bbae-4353-be30-db9ae106d4f3';\n\n    const getFilteredVillages = (db, ruleInput = []) => {\n        let query = 'subjectType.name = \"Village\" AND voided = false';\n        const queryParams = [];\n        \n        const registrationDateFilter = ruleInput && ruleInput.find(rule => rule.type === \"RegistrationDate\");\n        if (registrationDateFilter && registrationDateFilter.filterValue) {\n            const minValue = registrationDateFilter.filterValue.minValue;\n            const maxValue = registrationDateFilter.filterValue.maxValue;\n            const startDate = moment(minValue).startOf('day').toDate();\n            const endDate = moment(maxValue).endOf('day').toDate();\n            query += ' AND registrationDate >= $0 AND registrationDate <= $1';\n            queryParams.push(startDate, endDate);\n        }\n        \n        let villages = db.objects('Individual').filtered(query, ...queryParams);\n        \n        const addressFilter = ruleInput && ruleInput.find(rule => rule.type === \"Address\");\n        if (addressFilter && addressFilter.filterValue) {\n            const addressValue = addressFilter.filterValue\n                .filter(addr => addr && addr.type === \"Village\")\n                .map(addr => `\"${addr.uuid}\"`);\n                \n            if (addressValue.length > 0) {\n                const addressValueString = `{${addressValue.join(',')}}`;\n                villages = villages.filtered(`lowestAddressLevel.uuid in ${addressValueString}`);\n            }\n        }\n        \n        return Array.from(villages);\n    };\n    \n    const getVillagesWithAssessmentForms = (db) => {\n        return new Set(\n            db.objects('Encounter')\n                .filtered('encounterType.name = \"Village Assessment Form\" AND encounterDateTime != null and  voided = false')\n                .map(enc => enc.individual.uuid)\n        );\n    };\n    \n    const getVillagesWithLocationAssessment = (db) => {\n        return new Set(\n            db.objects('Individual')\n                .filtered('subjectType.name = \"Village\" AND voided = false')\n                .filtered(`SUBQUERY(observations, $o, $o.concept.uuid = '${LOCATION_ASSESSMENT_CONCEPT}' AND $o.valueJSON CONTAINS 'Yes').@count > 0`)\n                .map(village => village.uuid)\n        );\n    };\n    \n    const villages = getFilteredVillages(params.db, params.ruleInput || []);\n    const villagesWithForms = getVillagesWithAssessmentForms(params.db);\n    const locationAssessedVillages = getVillagesWithLocationAssessment(params.db);\n    \n    const completedAssessments = villages.filter(village => \n        villagesWithForms.has(village.uuid) || \n        locationAssessedVillages.has(village.uuid)\n    );\n    \n    return _.orderBy(completedAssessments, 'registrationDate', 'desc');\n};\n",
  "description" : "",
  "color" : "#49ef3d",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "5bbdc231-7600-4b51-995b-d73bafc02cfe",
  "id" : 5192,
  "name" : "Village Assessment Not Completed",
  "query" : "({params, imports}) => {\n    const _ = imports.lodash;\n    const moment = imports.moment;\n    const LOCATION_ASSESSMENT_CONCEPT = '348a795a-bbae-4353-be30-db9ae106d4f3';\n\n    const getFilteredVillages = (db, ruleInput = []) => {\n        let query = 'subjectType.name = \"Village\" AND voided = false';\n        const queryParams = [];\n        \n        const registrationDateFilter = ruleInput && ruleInput.find(rule => rule.type === \"RegistrationDate\");\n        if (registrationDateFilter && registrationDateFilter.filterValue) {\n            const minValue = registrationDateFilter.filterValue.minValue;\n            const maxValue = registrationDateFilter.filterValue.maxValue;\n            const startDate = moment(minValue).startOf('day').toDate();\n            const endDate = moment(maxValue).endOf('day').toDate();\n            query += ' AND registrationDate >= $0 AND registrationDate <= $1';\n            queryParams.push(startDate, endDate);\n        }\n        \n        let villages = db.objects('Individual').filtered(query, ...queryParams);\n        \n        const addressFilter = ruleInput && ruleInput.find(rule => rule.type === \"Address\");\n        if (addressFilter && addressFilter.filterValue) {\n            const addressValue = addressFilter.filterValue\n                .filter(addr => addr && addr.type === \"Village\")\n                .map(addr => `\"${addr.uuid}\"`);\n                \n            if (addressValue.length > 0) {\n                const addressValueString = `{${addressValue.join(',')}}`;\n                villages = villages.filtered(`lowestAddressLevel.uuid in ${addressValueString}`);\n            }\n        }\n        \n        return Array.from(villages);\n    };\n    \n    const getVillagesWithAssessments = (db) => {\n        return new Set(\n            db.objects('Encounter')\n                .filtered('encounterType.name = \"Village Assessment Form\" AND voided = false')\n                .map(enc => enc.individual.uuid)\n        );\n    };\n    \n    const getVillagesWithLocationAssessment = (db) => {\n        return new Set(\n            db.objects('Individual')\n                .filtered('subjectType.name = \"Village\" AND voided = false')\n                .filtered(`SUBQUERY(observations, $o, $o.concept.uuid = '${LOCATION_ASSESSMENT_CONCEPT}' AND $o.valueJSON CONTAINS 'Yes').@count > 0`)\n                .map(village => village.uuid)\n        );\n    };\n    \n    const villages = getFilteredVillages(params.db, params.ruleInput || []);\n    const assessedVillages = getVillagesWithAssessments(params.db);\n    const locationAssessedVillages = getVillagesWithLocationAssessment(params.db);\n    \n    const unassessedVillages = villages.filter(village => \n        !assessedVillages.has(village.uuid) && \n        !locationAssessedVillages.has(village.uuid)\n    );\n    \n    return _.orderBy(unassessedVillages, 'registrationDate', 'desc');\n};\n",
  "description" : "",
  "color" : "#f5b511",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "eed05543-ac8e-4262-897a-530da00a31f0",
  "id" : 2036,
  "name" : " Activities done",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({params, imports}) => {\n    const _= imports.lodash;\n    const moment = imports.moment;\n    \n    let Activities = params.db.objects('Individual').filtered('subjectType.name = \"Activity\" AND voided = false');\n\n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        let accountFilter =  params.ruleInput.filter(rule => rule.type === \"Concept\");\n        let registrationDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n                \n        \n        if(registrationDateFilter.length>0 && registrationDateFilter[0].filterValue){\n            let startDate = moment(registrationDateFilter[0].filterValue.minValue).startOf('day').toDate();\n            let endDate = moment(registrationDateFilter[0].filterValue.maxValue).startOf('day').toDate();                                   \n            \n            Activities = Activities.filtered(`registrationDate >= $0 AND registrationDate <= $1`,startDate,endDate);\n        }            \n\n\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            console.log(`address filter value`);\n            let addressValue = addressFilter[0].filterValue.filter((add) => add.type == \"Village\").map(add => {\n               return add.uuid;\n            });\n\n\n            if (addressValue.length > 0) {\n                let addressValueString = \"{\\\"\" + addressValue.join(\"\\\", \\\"\") + \"\\\"}\";\n                Activities = Activities.filtered(`lowestAddressLevel.uuid in ${addressValueString}`);\n            }\n        }\n\n        if(accountFilter.length > 0  && accountFilter[0].filterValue){\n            let accountName = accountFilter[0].filterValue.toLowerCase().trim();\n            Activities = Activities.filter(ind => {\n                let acName = ind.getObservationReadableValue(\"2978117c-a297-4171-99c6-23c3522ca0f8\");\n                return acName && acName.toLowerCase().includes(accountName)\n            });\n        }\n    }\n\n\n   return _.orderBy(Activities, ind => ind.registrationDate, 'desc');\n};",
  "description" : "",
  "color" : "#ebc944",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "8dded4ee-a054-41d8-9b7c-a84e79da5bc8",
  "id" : 2032,
  "name" : "Pending Distribution",
  "query" : "'use strict';\n({params, imports}) => {\n    const distributionComplete = (demand) => {\n        const calculateSumOfObservationValuesRecieved = (materialTypes) => {\n            return demand.getEncounters()\n                .filter((enc) => enc.encounterType.name === 'Dispatch receipt')\n                .flatMap((enc) => enc.getObservationValue('5dfb2f28-b866-4442-be01-0ed451c6aad9'))\n                .filter(obs => !_.isNil(obs))\n                .map((obs) => obs.getReadableValue())\n                .map((keyValues) => {\n                    const isQuantityMatching = _.get(_.find(keyValues, (kv) => kv['Quantity matching']), 'Quantity matching');\n                    const matchingQuantity = _.get(_.find(keyValues, (kv) => kv['Quantity (Dispatched)']), 'Quantity (Dispatched)') || 0;\n                    const notMatchingQuantity =\n                        _.get(_.find(keyValues, (kv) => kv['Quantity']), 'Quantity') || 0;\n                    const typeOfMaterial = _.get(_.find(keyValues, (kv) => kv['Type Of Material']), 'Type Of Material');\n                //    console.log('typeOfMaterial',typeOfMaterial);\n\n                    if (isQuantityMatching === 'Yes' && materialTypes.includes(typeOfMaterial))\n                        return matchingQuantity;\n                    else if (isQuantityMatching === 'No' && materialTypes.includes(typeOfMaterial))\n                        return notMatchingQuantity;\n                    else return 0;\n                })\n                .reduce((a, b) => a + b, 0);\n        };\n\n        const calculateSumOfObservationValuesDistributed = (materialTypes) => {\n            return demand.getEncounters()\n                .filter((enc) => enc.encounterType.name === 'Distribution')\n                .flatMap((enc) => enc.getObservationValue('3093c0f1-5e3f-47eb-92ed-0067b41b6f9c'))\n                .map((obs) => obs.getReadableValue())\n                .map((keyValues) => {\n                    const quantityNumber = _.get(_.find(keyValues, (kv) => kv['Quantity']), 'Quantity') || 0;\n                    const typeOfMaterial = _.get(_.find(keyValues, (kv) => kv['Type Of Material']), 'Type Of Material');\n                    return materialTypes.includes(typeOfMaterial) ? quantityNumber : 0;\n                })\n                .reduce((a, b) => a + b, 0);\n        };\n\n        return calculateSumOfObservationValuesRecieved(['Kit']) === calculateSumOfObservationValuesDistributed(['Kit'])\n            && calculateSumOfObservationValuesRecieved(['Contributed item']) === calculateSumOfObservationValuesDistributed(['Contributed item'])\n            && calculateSumOfObservationValuesRecieved(['Purchased item', 'Contributed track', 'Goonj product', 'High Value Material']) === calculateSumOfObservationValuesDistributed(['Purchased item', 'Contributed track', 'Goonj product', 'High Value Material'])\n    };\n    \n     let inds = params.db.objects('Individual')\n     .filter((demand) => demand.voided === false && !distributionComplete(demand))\n     \n     return _.orderBy(inds, ind => ind.registrationDate, 'desc')\n};\n",
  "description" : "Demands with dispatch receipt available but no distribution ",
  "color" : "#93a661",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "3ef6be72-ab86-444b-9c23-9d4c1396b4ab",
  "id" : 2039,
  "name" : "Total Inventories",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({params, imports}) => {\n    const _= imports.lodash;\n    const moment = imports.moment;\n        \n    let Inventories = params.db.objects('Individual').filtered('subjectType.name = \"Inventory Item\" AND voided = false');\n     \n     \n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        let accountFilter =  params.ruleInput.filter(rule => rule.type === \"Concept\");\n        let registrationDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n                \n        \n        if(registrationDateFilter.length>0 && registrationDateFilter[0].filterValue){\n            let startDate = moment(registrationDateFilter[0].filterValue.minValue).startOf('day').toDate();\n            let endDate = moment(registrationDateFilter[0].filterValue.maxValue).startOf('day').toDate();                                   \n            \n            Inventories = Inventories.filtered(`registrationDate >= $0 AND registrationDate <= $1`,startDate,endDate);\n        }    \n        \n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            let addressValue = addressFilter[0].filterValue.filter((add) => add.type == \"District\").map(add => add.uuid);\n\n            if (addressValue.length > 0) {\n                let addressValueString = \"{\\\"\" + addressValue.join(\"\\\", \\\"\") + \"\\\"}\";\n                Inventories = Inventories.filtered(`lowestAddressLevel.uuid in ${addressValueString}`);\n            }\n        }\n        \n        if(accountFilter.length > 0  && accountFilter[0].filterValue){\n            let accountName = accountFilter[0].filterValue.toLowerCase().trim();\n            Inventories = Inventories.filter(ind => {\n                let acName = ind.getObservationReadableValue(\"41de93e4-daaf-4207-bf70-b32939d09ea5\");\n                return acName && acName.toLowerCase().includes(accountName)\n            });\n        }\n        \n       \n    }        \n    Inventories = Inventories.filter(ind => ind.getObservationReadableValue(\"Current Quantity\")>0);     \n     \n     return _.orderBy(Inventories, ind => ind.registrationDate, 'desc');\n};\n\n\n",
  "description" : "",
  "color" : "#b975eb",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
} ]