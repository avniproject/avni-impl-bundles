[ {
  "uuid" : "6085c2f4-52e7-4b08-85b6-d6b2612b4cf5",
  "id" : 6716,
  "name" : "Scheduled visits",
  "color" : "#388e3c",
  "nested" : false,
  "count" : 1,
  "standardReportCardType" : "27020b32-c21b-43a4-81bd-7b88ad3a6ef0",
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "85ce7239-e8b5-4e57-b07d-66c18cee47b2",
  "id" : 6717,
  "name" : "Overdue visits",
  "color" : "#d32f2f",
  "nested" : false,
  "count" : 1,
  "standardReportCardType" : "9f88bee5-2ab9-4ac4-ae19-d07e9715bdb5",
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "a1673f8a-c394-4bcf-8b6f-63d83a5443e2",
  "id" : 6718,
  "name" : "Total",
  "color" : "#ffffff",
  "nested" : false,
  "count" : 1,
  "standardReportCardType" : "1fbcadf3-bf1a-439e-9e13-24adddfbf6c0",
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "f366f35a-5c4f-4ff7-b510-2dc9f5f88847",
  "id" : 6719,
  "name" : "Recent registrations",
  "color" : "#ffffff",
  "nested" : false,
  "count" : 1,
  "standardReportCardType" : "88a7514c-48c0-4d5d-a421-d074e43bb36c",
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "standardReportCardInputRecentDuration" : "{\"value\":\"1\",\"unit\":\"days\"}",
  "voided" : false
}, {
  "uuid" : "e1036b69-df46-4351-9916-10cd4cfcb6bd",
  "id" : 6720,
  "name" : "Recent enrolments",
  "color" : "#ffffff",
  "nested" : false,
  "count" : 1,
  "standardReportCardType" : "a5efc04c-317a-4823-a203-e62603454a65",
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "standardReportCardInputRecentDuration" : "{\"value\":\"1\",\"unit\":\"days\"}",
  "voided" : false
}, {
  "uuid" : "dd961ee1-9d4e-4ec9-99f0-99b36672be7c",
  "id" : 6721,
  "name" : "Recent visits",
  "color" : "#ffffff",
  "nested" : false,
  "count" : 1,
  "standardReportCardType" : "77b5b3fa-de35-4f24-996b-2842492ea6e0",
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "standardReportCardInputRecentDuration" : "{\"value\":\"1\",\"unit\":\"days\"}",
  "voided" : false
}, {
  "uuid" : "7311597c-bab9-4fa3-bee7-be4333de4c66",
  "id" : 6722,
  "name" : "Total claims registered this year",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({ params, imports }) => {\n    let userUUID = params.user.userUUID;\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n\n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type == \"Address\");\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            console.log(addressFilter[0].filterValue);\n            addressValue = addressFilter[0].filterValue\n                .filter(add => add.type == \"Administrative Unit\")\n                .map(add => add.uuid);\n        }\n\n        let rangeDateFilter = params.ruleInput.filter(rule => rule.type == \"RegistrationDate\");\n        if (rangeDateFilter.length > 0 && rangeDateFilter[0].filterValue) {\n            let minDateInput = new Date(rangeDateFilter[0].filterValue.minValue);\n            let maxDateInput = new Date(rangeDateFilter[0].filterValue.maxValue);\n            \n            minDateValue = new Date(minDateInput.getFullYear(), minDateInput.getMonth(), minDateInput.getDate(), 0, 0, 0, 0);\n            maxDateValue = new Date(maxDateInput.getFullYear(), maxDateInput.getMonth(), maxDateInput.getDate(), 23, 59, 59, 999);\n        }\n    }\n\n    if (!minDateValue || !maxDateValue) {\n        const currentDate = new Date();\n        const currentYear = currentDate.getFullYear();\n        const currentMonth = currentDate.getMonth() + 1;\n        \nif (currentMonth >= 4) {\n    minDateValue = new Date(currentYear, 3, 1, 0, 0, 0, 0);\n    maxDateValue = new Date(currentYear + 1, 3, 0, 23, 59, 59, 999);\n} else {\n    minDateValue = new Date(currentYear - 1, 3, 1, 0, 0, 0, 0);\n    maxDateValue = new Date(currentYear, 3, 0, 23, 59, 59, 999);\n}\n    }\n\n    let query = `voided = false AND subjectType.name = 'Claim'`;\n    \n    if (addressValue.length > 0) {\n        console.log('in address if');\n        let output = addressValue.map(item => `'${item}'`).join(\", \");\n        query += ` AND lowestAddressLevel.uuid IN {${output}}`;\n    }\n\n    query += ` AND registrationDate >= $1 AND registrationDate <= $2`;\n    query += ` AND (createdByUUID == NULL OR createdByUUID = $0)`;\n\n    return params.db.objects('Individual')\n        .filtered(query, userUUID, minDateValue, maxDateValue);\n};",
  "description" : "",
  "color" : "#f8efe7",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "f5322473-00da-4a1b-93a0-b68ef439f8a4",
  "id" : 6723,
  "name" : "Total active litigation cases – Other Field Workers",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({params, imports}) => {\n    let UUIDs = params.user.userUUID;\n    \n    let minDateValue = null;\n    let maxDateValue = null;\n    const NEXT_DATE_CONCEPT_UUID = 'cd8aa6fb-9277-47a5-b082-a70c76d3cc56';\n    \n    if (params.ruleInput) {        \n        // Process Next Date filter\n        const nextDateFilter = params.ruleInput.find(rule => \n            rule.type === \"Concept\" && \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.uuid === NEXT_DATE_CONCEPT_UUID\n        );\n        \n        if (nextDateFilter && nextDateFilter.filterValue) {\n            const minDateInput = new Date(nextDateFilter.filterValue.minValue);\n            const maxDateInput = new Date(nextDateFilter.filterValue.maxValue);\n            \n            if (!isNaN(minDateInput.getTime()) && !isNaN(maxDateInput.getTime())) {\n                minDateValue = new Date(minDateInput);\n                minDateValue.setHours(0, 0, 0, 0);\n                maxDateValue = new Date(maxDateInput);\n                maxDateValue.setHours(23, 59, 59, 999);\n            }\n        }\n    }\n    \n    let query = `voided = false `;\n    \n    /*  252f4c55-d113-4951-8ebb-eed01b9ccbb9 ---> Nature of Case  \n        b1927aeb-ab4c-46a6-8eff-6ccdf38f5478 ---> Status of Case\n    */\n    \n    \n    let enrolments = params.db.objects(\"ProgramEnrolment\").filtered(`\n      program.name = 'Case Status' \n      AND voided = false\n      AND programExitDateTime = null \n      AND SUBQUERY(observations, $observation, \n            $observation.concept.uuid = 'b1927aeb-ab4c-46a6-8eff-6ccdf38f5478' AND \n            (\n                  $observation.valueJSON CONTAINS 'df2c6f91-cf67-494c-9e85-8816918f0fed' \n            )\n      ).@count > 0 AND (createdByUUID = NULL OR createdByUUID != $0) AND ${query}`, UUIDs);\n    \n    // Apply Next Date filter if date range is provided\n    if (minDateValue && maxDateValue) {\n        const minTime = minDateValue.getTime();\n        const maxTime = maxDateValue.getTime();\n        \n        enrolments = enrolments.filter(enrolment => {\n            const nextDateObs = enrolment.observations && enrolment.observations.find(obs => \n                obs && obs.concept && \n                obs.concept.uuid === NEXT_DATE_CONCEPT_UUID && \n                obs.valueJSON\n            );\n            \n            if (!nextDateObs) return false;\n            \n            const dateObj = JSON.parse(nextDateObs.valueJSON);\n            const dateValue = dateObj && dateObj.value;\n            if (!dateValue) return false;\n            \n            const date = new Date(dateValue).getTime();\n            if (isNaN(date)) return false;\n            \n            return date >= minTime && date <= maxTime;\n        });\n    }\n    \n    return enrolments.map((enrl) => enrl.individual);\n};",
  "description" : "",
  "color" : "#f8e781",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "cc0edb0f-78be-48f7-bfb6-e45819de4f36",
  "id" : 6724,
  "name" : "External Trainings - Own Data",
  "query" : "'use strict';\n\n({ params, imports }) => {\n    let UUIDs = params.user.userUUID;\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n    let queryParams = [UUIDs];\n\n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            addressValue = addressFilter[0].filterValue\n                .filter(add => add.type === \"Administrative Unit\")\n                .map(add => add.name);\n        }\n\n        let rangeDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n        if (rangeDateFilter.length > 0 && rangeDateFilter[0].filterValue) {\n            let minDateInput = new Date(rangeDateFilter[0].filterValue.minValue);\n            let maxDateInput = new Date(rangeDateFilter[0].filterValue.maxValue);\n\n            minDateValue = new Date(minDateInput.getFullYear(), minDateInput.getMonth(), minDateInput.getDate(), 0, 0, 0, 0);\n            maxDateValue = new Date(maxDateInput.getFullYear(), maxDateInput.getMonth(), maxDateInput.getDate(), 23, 59, 59, 999);\n        }\n    }\n\n    let query = `\n        individual.voided = false \n        AND encounterType.name = \"External Training\"\n        AND cancelDateTime = NULL \n        AND (createdByUUID = NULL OR createdByUUID = $0)\n    `;\n    \n    if (minDateValue && maxDateValue) {\n        query += ` AND encounterDateTime >= $${queryParams.length} AND encounterDateTime <= $${queryParams.length + 1}`;\n        queryParams.push(minDateValue, maxDateValue);\n    }\n\n    if (addressValue.length > 0) {\n        query += ` AND individual.lowestAddressLevel.name IN $${queryParams.length}`;\n        queryParams.push(addressValue);\n    }\n    \n    let externalTraining = params.db.objects('Encounter').filtered(query, ...queryParams);\n\n    return {\n        primaryValue: externalTraining.length,\n        lineListFunction: () => externalTraining.map(enc => enc.individual)\n    };\n};\n",
  "description" : "",
  "color" : "#e6eefa",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "d9d046c9-fe08-4049-8db2-824020a76555",
  "id" : 6725,
  "name" : "Active Campaign - Other Field Workers data ",
  "query" : "'use strict';\n\n({ params, imports }) => {\n    let userUUID = params.user.userUUID;\n    let today = new Date();\n    today.setHours(0, 0, 0, 0); // Normalize time to midnight\n\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n    let query = \"voided == false AND subjectType.name == 'Campaign'\"; // Initialize query\n    let queryParams = [];\n\n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            addressValue = addressFilter[0].filterValue\n                .filter(add => add.type === \"Administrative Unit\")\n                .map(add => add.uuid);\n        }\n        let rangeDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n        if (rangeDateFilter.length > 0 && rangeDateFilter[0].filterValue) {\n            let minDateInput = new Date(rangeDateFilter[0].filterValue.minValue);\n            let maxDateInput = new Date(rangeDateFilter[0].filterValue.maxValue);\n\n            minDateValue = new Date(minDateInput.getFullYear(), minDateInput.getMonth(), minDateInput.getDate(), 0, 0, 0, 0);\n            maxDateValue = new Date(maxDateInput.getFullYear(), maxDateInput.getMonth(), maxDateInput.getDate(), 23, 59, 59, 999);\n        }\n    }\n\n    if (minDateValue && maxDateValue) {\n        query += ` AND registrationDate >= $${queryParams.length} AND registrationDate <= $${queryParams.length + 1}`;\n        queryParams.push(minDateValue, maxDateValue);\n    }\n\n    if (addressValue.length > 0) {\n        query += ` AND lowestAddressLevel.name IN $${queryParams.length}`;\n        queryParams.push(addressValue);\n    }\n    \n    let allIndividuals = params.db.objects(\"Individual\")\n        .filtered(query, ...queryParams)\n        .filtered(`\n            SUBQUERY(observations, $obs, $obs.concept.uuid == 'c63113ca-5dec-4048-bf99-fe51f36f7dfb').@count > 0 \n            AND (createdByUUID == null OR createdByUUID != $0)\n        `, userUUID);\n    let validIndividuals = allIndividuals.filter(ind => {\n        return ind.observations.some(obs => {\n            if (obs.concept.uuid === 'c63113ca-5dec-4048-bf99-fe51f36f7dfb' && obs.valueJSON) {\n                let parsedValue = typeof obs.valueJSON === \"string\" ? JSON.parse(obs.valueJSON) : obs.valueJSON;\n                \n                let dateString = parsedValue ? (parsedValue.answer || parsedValue.value) : null;\n                if (!dateString) return false;\n                \n                let endDate = new Date(dateString);\n                return !isNaN(endDate) && endDate > today;\n            }\n            return false;\n        });\n    });\n\n    return imports.lodash.uniqBy(validIndividuals, 'uuid');\n};",
  "description" : "",
  "color" : "#f8f7e7",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "6ef87d47-e2b3-45e7-a11d-72b10dfdd09e",
  "id" : 6726,
  "name" : "Active Campaign - Own Data",
  "query" : "'use strict';\n\n({ params, imports }) => {\n    let userUUID = params.user.userUUID;\n    let today = new Date();\n    today.setHours(0, 0, 0, 0);\n\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n    let query = \"voided == false AND subjectType.name == 'Campaign'\"; // Initialize query\n    let queryParams = [];\n\n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        console.log('addressFilter-->',addressFilter);\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            addressValue = addressFilter[0].filterValue\n                .filter(add => add.type === \"Administrative Unit\")\n                .map(add => add.uuid);\n        }\n        \n        console.log('addressValue--->',addressValue);\n        \n        let rangeDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n        if (rangeDateFilter.length > 0 && rangeDateFilter[0].filterValue) {\n            let minDateInput = new Date(rangeDateFilter[0].filterValue.minValue);\n            let maxDateInput = new Date(rangeDateFilter[0].filterValue.maxValue);\n\n            minDateValue = new Date(minDateInput.getFullYear(), minDateInput.getMonth(), minDateInput.getDate(), 0, 0, 0, 0);\n            maxDateValue = new Date(maxDateInput.getFullYear(), maxDateInput.getMonth(), maxDateInput.getDate(), 23, 59, 59, 999);\n        }\n    }\n\n    if (minDateValue && maxDateValue) {\n        query += ` AND registrationDate >= $${queryParams.length} AND registrationDate <= $${queryParams.length + 1}`;\n        queryParams.push(minDateValue, maxDateValue);\n    }\n\n    if (addressValue.length > 0) {\n        query += ` AND lowestAddressLevel.name IN $${queryParams.length}`;\n        queryParams.push(addressValue);\n    }\n    \n    console.log('queryParams--->',queryParams);\n    \n    console.log('query--->',query);\n    \n    let allIndividuals = params.db.objects(\"Individual\")\n        .filtered(query, ...queryParams)\n        .filtered(`\n            SUBQUERY(observations, $obs, $obs.concept.uuid == 'c63113ca-5dec-4048-bf99-fe51f36f7dfb').@count > 0 \n            AND (createdByUUID == null OR createdByUUID == $0)\n        `, userUUID);\n    let validIndividuals = allIndividuals.filter(ind => {\n        return ind.observations.some(obs => {\n            if (obs.concept.uuid === 'c63113ca-5dec-4048-bf99-fe51f36f7dfb' && obs.valueJSON) {\n                let parsedValue = typeof obs.valueJSON === \"string\" ? JSON.parse(obs.valueJSON) : obs.valueJSON;\n                \n                let dateString = parsedValue ? (parsedValue.answer || parsedValue.value) : null;\n                if (!dateString) return false;\n                \n                let endDate = new Date(dateString);\n                return !isNaN(endDate) && endDate > today;\n            }\n            return false;\n        });\n    });\n\n    return imports.lodash.uniqBy(validIndividuals, 'uuid');\n};",
  "description" : "",
  "color" : "#f8efe7",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "ad412b45-198e-4631-ba92-950a016ff43d",
  "id" : 6727,
  "name" : "Total active pre lit cases – Other Field Workers ",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({params, imports}) => {\n    let UUIDs = params.user.userUUID;\n    let caseStatus = params.db.objects(\"ProgramEnrolment\")\n    .filtered(`\n      program.name = 'Case Status' \n      AND programExitDateTime = null \n      AND individual.voided = false\n      AND SUBQUERY(observations, $observation,\n            $observation.concept.uuid = 'b1927aeb-ab4c-46a6-8eff-6ccdf38f5478' AND\n            (\n                  $observation.valueJSON CONTAINS 'b5d60cc0-716a-4980-ac26-13559bfb31ac' \n            )\n      ).@count > 0 AND createdByUUID != $0`,UUIDs\n    ).map((enrl) => enrl.individual);\n    \n    return caseStatus;\n};",
  "description" : "",
  "color" : "#ebe7f8",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "85694b94-40e9-459e-af1d-ab1a61ad5250",
  "id" : 6728,
  "name" : "No. of total Active Cases  (voided~3844)",
  "description" : "Count of all cases whose \"Status of case \" is not Closed or Disposed",
  "color" : "#ff0000",
  "nested" : false,
  "count" : 1,
  "standardReportCardType" : "1fbcadf3-bf1a-439e-9e13-24adddfbf6c0",
  "standardReportCardInputSubjectTypes" : [ "0bc1dbf5-6790-4c9b-b5eb-d241ec6b0379" ],
  "standardReportCardInputPrograms" : [ "73651784-823d-43b0-a967-7e4508a6d12f" ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : true
}, {
  "uuid" : "63d51ddf-1a82-43bc-83cb-2136693017cf",
  "id" : 6729,
  "name" : "Count of total outreach registered till date (voided~3843)",
  "description" : "",
  "color" : "#ff0000",
  "nested" : false,
  "count" : 1,
  "standardReportCardType" : "1fbcadf3-bf1a-439e-9e13-24adddfbf6c0",
  "standardReportCardInputSubjectTypes" : [ "a92cdaae-19cd-4778-920c-235e30c5ecdf" ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : true
}, {
  "uuid" : "462a7927-aa88-4813-80ea-c0f9846be5ce",
  "id" : 6730,
  "name" : "Internal Trainings - Other Field Workers data ",
  "query" : "'use strict';\n\n({ params, imports }) => {\n    let UUIDs = params.user.userUUID;\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n    let queryParams = [UUIDs];\n\n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            addressValue = addressFilter[0].filterValue\n                .filter(add => add.type === \"Administrative Unit\")\n                .map(add => add.name);\n        }\n\n        let rangeDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n        if (rangeDateFilter.length > 0 && rangeDateFilter[0].filterValue) {\n            let minDateInput = new Date(rangeDateFilter[0].filterValue.minValue);\n            let maxDateInput = new Date(rangeDateFilter[0].filterValue.maxValue);\n\n            minDateValue = new Date(minDateInput.getFullYear(), minDateInput.getMonth(), minDateInput.getDate(), 0, 0, 0, 0);\n            maxDateValue = new Date(maxDateInput.getFullYear(), maxDateInput.getMonth(), maxDateInput.getDate(), 23, 59, 59, 999);\n        }\n    }\n\n    let query = `\n        individual.voided = false \n        AND encounterType.name = \"Internal Training\"\n        AND cancelDateTime = NULL \n        AND (createdByUUID = NULL OR createdByUUID != $0)\n    `;\n\n    if (minDateValue && maxDateValue) {\n        query += ` AND encounterDateTime >= $${queryParams.length} AND encounterDateTime <= $${queryParams.length + 1}`;\n        queryParams.push(minDateValue, maxDateValue);\n    }\n\n    if (addressValue.length > 0) {\n        query += ` AND individual.lowestAddressLevel.name IN $${queryParams.length}`;\n        queryParams.push(addressValue);\n    }\n\n    let internalTraining = params.db.objects('Encounter').filtered(query, ...queryParams);\n\n    return {\n        primaryValue: internalTraining.length,\n        lineListFunction: () => internalTraining.map(enc => enc.individual)\n    };\n};",
  "description" : "",
  "color" : "#f8f7e7",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "347844fb-96d2-48ef-8dc1-d361852dc54a",
  "id" : 6731,
  "name" : "Number of Interns - Own Data",
  "query" : "'use strict';\n({ params, imports }) => {\n    let userUUID = params.user.userUUID;\n    let addressValue = [];\n    let asOnDateValue = null;\n    let minDateValue = null;\n    let maxDateValue = null;\n\n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type == \"Address\");\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            addressValue = addressFilter[0].filterValue\n                .filter(add => add.type == \"Administrative Unit\")\n                .map(add => add.uuid);\n        }\n\n        let asOnDateFilter = params.ruleInput.filter(rule => rule.type == \"AsOnDate\");\n        if (asOnDateFilter.length > 0 && asOnDateFilter[0].filterValue) {\n            let dateInput = new Date(asOnDateFilter[0].filterValue);\n            asOnDateValue = new Date(dateInput.getFullYear(), dateInput.getMonth(), dateInput.getDate(), 0, 0, 0, 0);\n        }\n\n        let rangeDateFilter = params.ruleInput.filter(rule => rule.type == \"RegistrationDate\");\n        if (rangeDateFilter.length > 0 && rangeDateFilter[0].filterValue) {\n            let minDateInput = new Date(rangeDateFilter[0].filterValue.minValue);\n            let maxDateInput = new Date(rangeDateFilter[0].filterValue.maxValue);\n            \n            minDateValue = new Date(minDateInput.getFullYear(), minDateInput.getMonth(), minDateInput.getDate(), 0, 0, 0, 0);\n            maxDateValue = new Date(maxDateInput.getFullYear(), maxDateInput.getMonth(), maxDateInput.getDate(), 23, 59, 59, 999); // Ensures end of day for max date\n        }\n    }\n\n    let query = `voided = false AND subjectType.name = 'Intern'`;\n\n    if (addressValue.length > 0) {\n        let output = addressValue.map(item => `'${item}'`).join(\", \");\n        query += ` AND lowestAddressLevel.uuid IN {${output}}`;\n    }\n\n    if (asOnDateValue) {\n        query += ` AND registrationDate == $1`;\n    }\n\n    if (minDateValue && maxDateValue) {\n        query += ` AND registrationDate >= $2 AND registrationDate <= $3`;\n    }\n\n    query += ` AND (createdByUUID == NULL OR createdByUUID == $0)`;\n\n    console.log('Final Query:', query);\n\n    return params.db.objects('Individual')\n        .filtered(query, userUUID, asOnDateValue, minDateValue, maxDateValue);\n};",
  "description" : "",
  "color" : "#ebe7f8",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "951f5f88-ad00-4403-bb20-6cbf651e5dff",
  "id" : 6732,
  "name" : "Number of Interns - Other Field Workers data",
  "query" : "'use strict';\n({ params, imports }) => {\n    let userUUID = params.user.userUUID;\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n\n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type == \"Address\");\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            addressValue = addressFilter[0].filterValue\n                .filter(add => add.type == \"Administrative Unit\")\n                .map(add => add.uuid);\n        }\n\n        let rangeDateFilter = params.ruleInput.filter(rule => rule.type == \"RegistrationDate\");\n        if (rangeDateFilter.length > 0 && rangeDateFilter[0].filterValue) {\n            let minDateInput = new Date(rangeDateFilter[0].filterValue.minValue);\n            let maxDateInput = new Date(rangeDateFilter[0].filterValue.maxValue);\n            \n            minDateValue = new Date(minDateInput.getFullYear(), minDateInput.getMonth(), minDateInput.getDate(), 0, 0, 0, 0);\n            maxDateValue = new Date(maxDateInput.getFullYear(), maxDateInput.getMonth(), maxDateInput.getDate(), 23, 59, 59, 999);\n        }\n    }\n\n    let query = `voided = false AND subjectType.name = 'Intern'`;\n\n    if (addressValue.length > 0) {\n        let output = addressValue.map(item => `'${item}'`).join(\", \");\n        query += ` AND lowestAddressLevel.uuid IN {${output}}`;\n    }\n\n    if (minDateValue && maxDateValue) {\n        query += ` AND registrationDate >= $1 AND registrationDate <= $2`;\n    }\n\n    query += ` AND (createdByUUID == NULL OR createdByUUID != $0)`;\n\n    return params.db.objects('Individual')\n        .filtered(query, userUUID, minDateValue, maxDateValue);\n};",
  "description" : "Total number of interns in catchment",
  "color" : "#e6eefa",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "ef43ae77-576f-496e-9717-b24e5e1a3c75",
  "id" : 6733,
  "name" : "External Trainings - Other Field Workers data ",
  "query" : "'use strict';\n\n({ params, imports }) => {\n    let UUIDs = params.user.userUUID;\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n    let queryParams = [UUIDs];\n\n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            addressValue = addressFilter[0].filterValue\n                .filter(add => add.type === \"Administrative Unit\")\n                .map(add => add.name);\n        }\n\n        let rangeDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n        if (rangeDateFilter.length > 0 && rangeDateFilter[0].filterValue) {\n            let minDateInput = new Date(rangeDateFilter[0].filterValue.minValue);\n            let maxDateInput = new Date(rangeDateFilter[0].filterValue.maxValue);\n\n            minDateValue = new Date(minDateInput.getFullYear(), minDateInput.getMonth(), minDateInput.getDate(), 0, 0, 0, 0);\n            maxDateValue = new Date(maxDateInput.getFullYear(), maxDateInput.getMonth(), maxDateInput.getDate(), 23, 59, 59, 999);\n        }\n    }\n\n    let query = `\n        individual.voided = false \n        AND encounterType.name = \"External Training\"\n        AND cancelDateTime = NULL \n        AND (createdByUUID = NULL OR createdByUUID != $0)\n    `;\n\n    let queryParams = [UUIDs];\n\n    if (minDateValue && maxDateValue) {\n        query += ` AND encounterDateTime >= $${queryParams.length} AND encounterDateTime <= $${queryParams.length + 1}`;\n        queryParams.push(minDateValue, maxDateValue);\n    }\n\n    if (addressValue.length > 0) {\n        query += ` AND individual.lowestAddressLevel.name IN $${queryParams.length}`;\n        queryParams.push(addressValue);\n    }\n\n    \n    let externalTraining = params.db.objects('Encounter').filtered(query, ...queryParams);\n\n    return {\n        primaryValue: externalTraining.length,\n        lineListFunction: () => externalTraining.map(enc => enc.individual)\n    };\n};\n",
  "description" : "",
  "color" : "#ebe7f8",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "12672744-33e7-4330-95d3-bba2a264945b",
  "id" : 6734,
  "name" : "No. of total Active Cases - Own Data\n",
  "query" : "'use strict';\n({params, imports}) => {\n    let UUIDs = params.user.userUUID;\n    \n    let filterValues = {\n        natureOfCase: [],\n        activeStage1: [],\n        activeStage2: [],\n        activeStage3: [],\n        activeStage4: [],\n        activeStage5: [],\n        activeStage6: []\n    };\n    \n    if (params.ruleInput) {\n        let caseFilters = params.ruleInput.filter(rule => rule.type === \"Concept\");\n        const caseMapping = {\n            'Nature of Case': 'natureOfCase',\n            'Theme of case': 'themeOfCase',\n            'Stage of Active (pre-litigation) - Criminal Prosecution/ Defence fresh filing': 'activeStage1',\n            'Stage of Active (litigation) status - Criminal Prosecution/ Defence fresh filing': 'activeStage2',\n            'Stage of Active (pre-litigation) - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage3',\n            'Stage of Active (litigation) status - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage4',\n            'Stage of Active (pre-litigation)': 'activeStage5',\n            'Stage of Active (litigation) status': 'activeStage6'\n        };\n    \n        for (let i = 0; i < caseFilters.length; i++) {\n            let filter = caseFilters[i];\n            if (filter.observationBasedFilter && filter.observationBasedFilter.concept) {\n                let key = caseMapping[filter.observationBasedFilter.concept.name];\n                if (key && filter.filterValue) {\n                    filterValues[key] = filter.filterValue.map(add => add.uuid);\n                }\n            }\n        }\n    }\n        \n    function buildQueryCondition(uuid, filterArray) {\n        if (filterArray.length === 0) return \"\";\n        let conditions = filterArray.map(uuid => `$observation.valueJSON CONTAINS '${uuid}'`).join(' OR ');\n        return ` \n          AND SUBQUERY(observations, $observation,\n            $observation.concept.uuid = '${uuid}' \n            AND (${conditions})\n          ).@count > 0`;\n    }\n\n    let query = `voided = false`;\n  \n    query += buildQueryCondition('252f4c55-d113-4951-8ebb-eed01b9ccbb9', filterValues.natureOfCase);\n    query += buildQueryCondition('e1945ebb-19df-4055-b9c2-9fbcda959671', filterValues.activeStage1);\n    query += buildQueryCondition('ee698620-9b14-4379-a7de-6098c9f009b0', filterValues.activeStage2);\n    query += buildQueryCondition('c4d9571c-1f78-45d7-a415-83589595ae9d', filterValues.activeStage3);\n    query += buildQueryCondition('aa7cfb95-21f2-48fb-9c28-e6a46c3d88a8', filterValues.activeStage4);\n    query += buildQueryCondition('c8bafd78-6fdf-48ac-bd54-f180b00ce46f', filterValues.activeStage5);\n    query += buildQueryCondition('065e005a-3203-4192-91ad-37e55480a695', filterValues.activeStage6);\n    \n    let caseStatus = params.db.objects(\"ProgramEnrolment\")\n    .filtered(query)\n    .filtered(`\n      program.name = 'Case Status' \n      AND programExitDateTime = null \n      AND individual.voided = false\n      AND SUBQUERY(observations, $observation,\n            $observation.concept.uuid = 'b1927aeb-ab4c-46a6-8eff-6ccdf38f5478' AND\n            (\n              $observation.valueJSON CONTAINS '65688e86-a632-4e70-9ef8-4f19b0fc3bee' \n              OR \n              $observation.valueJSON CONTAINS 'd56b69db-da83-4f60-9a3f-4cc159e5e191'\n            )\n      ).@count == 0 AND (createdByUUID = NULL OR createdByUUID = $0) AND ${query}`,UUIDs\n    ).map((enrl) => enrl.individual);\n    \n    return caseStatus;\n};",
  "description" : "",
  "color" : "#dbff00",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "5223ae04-52fa-4c19-ac4a-6c7945de6569",
  "id" : 6735,
  "name" : "Cases with non-court next steps scheduled in the next month - Other Field Workers data ",
  "query" : "'use strict';\n({ params, imports }) => {\n    let UUIDs = params.user.userUUID;\n    let currentDate = new Date();\n    let nextMonthDate = new Date();\n    nextMonthDate.setMonth(currentDate.getMonth() + 1);\n    \n    let filterValues = {\n        natureOfCase: [],\n        themeOfCase:  [],\n        activeStage1: [],\n        activeStage2: [],\n        activeStage3: [],\n        activeStage4: [],\n        activeStage5: [],\n        activeStage6: []\n    };\n    \n    let asOnDateValue = null;\n    \n    if (params.ruleInput) {\n        let asOnDateFilter = params.ruleInput.find(rule => rule.type === \"AsOnDate\");\n        if (asOnDateFilter && asOnDateFilter.filterValue) {\n            let dateInput = new Date(asOnDateFilter.filterValue);\n            asOnDateValue = new Date(dateInput.getFullYear(), dateInput.getMonth(), dateInput.getDate(), 0, 0, 0, 0);\n        }\n    \n        let caseFilters = params.ruleInput.filter(rule => rule.type === \"Concept\");\n    \n        const caseMapping = {\n            'Nature of Case': 'natureOfCase',\n            'Theme of case': 'themeOfCase',\n            'Stage of Active (pre-litigation) - Criminal Prosecution/ Defence fresh filing': 'activeStage1',\n            'Stage of Active (litigation) status - Criminal Prosecution/ Defence fresh filing': 'activeStage2',\n            'Stage of Active (pre-litigation) - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage3',\n            'Stage of Active (litigation) status - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage4',\n            'Stage of Active (pre-litigation)': 'activeStage5',\n            'Stage of Active (litigation) status': 'activeStage6'\n        };\n    \n        for (let i = 0; i < caseFilters.length; i++) {\n            let filter = caseFilters[i];\n            if (filter.observationBasedFilter && filter.observationBasedFilter.concept) {\n                let key = caseMapping[filter.observationBasedFilter.concept.name];\n                if (key && filter.filterValue) {\n                    filterValues[key] = filter.filterValue.map(add => add.uuid);\n                }\n            }\n        }\n    }\n    \n    function buildQueryCondition(uuid, filterArray, observationType = 'individual.enrolments.observations') {\n        if (filterArray.length === 0) return \"\";\n        let conditions = filterArray.map(uuid => `$observation.valueJSON CONTAINS '${uuid}'`).join(' OR ');\n        return ` \n          AND SUBQUERY(${observationType}, $observation,\n            $observation.concept.uuid = '${uuid}' \n            AND (${conditions})\n          ).@count > 0`;\n    }\n    \n    let query = `individual.voided = false`;\n    \n    query += buildQueryCondition('252f4c55-d113-4951-8ebb-eed01b9ccbb9', filterValues.natureOfCase);\n    query += buildQueryCondition('05865e79-c454-47c2-af03-fc719213b576', filterValues.themeOfCase, 'individual.observations');\n    query += buildQueryCondition('e1945ebb-19df-4055-b9c2-9fbcda959671', filterValues.activeStage1);\n    query += buildQueryCondition('ee698620-9b14-4379-a7de-6098c9f009b0', filterValues.activeStage2);\n    query += buildQueryCondition('c4d9571c-1f78-45d7-a415-83589595ae9d', filterValues.activeStage3);\n    query += buildQueryCondition('aa7cfb95-21f2-48fb-9c28-e6a46c3d88a8', filterValues.activeStage4);\n    query += buildQueryCondition('c8bafd78-6fdf-48ac-bd54-f180b00ce46f', filterValues.activeStage5);\n    query += buildQueryCondition('065e005a-3203-4192-91ad-37e55480a695', filterValues.activeStage6);\n    \n    \n    let encounters = params.db.objects(\"Encounter\")\n    .filtered(query) \n    .filtered(`\n        encounterType.name = 'Case Activity Register' \n        AND voided = false\n        AND individual.voided = false\n        AND SUBQUERY(observations, $obs,\n            $obs.concept.uuid = '12003b39-078c-4f63-aa93-ecfb2e774557'\n            AND $obs.valueJSON CONTAINS '03ead610-1596-4a1f-b57d-07792c6e66b6'\n        ).@count > 0 \n        AND (createdByUUID == NULL OR createdByUUID != $0)\n    `, UUIDs);\n    \n    let validEncounters = encounters.filter(encounter => {\n        return encounter.observations.some(obs => {\n            if (obs.concept.uuid === '3fe8e744-2225-420a-8d00-93f16cacf77b' && obs.valueJSON) {\n                let parsedValue = typeof obs.valueJSON === \"string\" ? JSON.parse(obs.valueJSON) : obs.valueJSON;\n                let dateString = null;\n                if (parsedValue) {\n                    if (parsedValue.answer) {\n                        dateString = parsedValue.answer;\n                    } else if (parsedValue.value) {\n                        dateString = parsedValue.value;\n                    }\n                }\n                if (!dateString) return false;\n                let nextDate = new Date(dateString);\n                if (asOnDateValue) {\n                  return !isNaN(nextDate) && nextDate.getTime() === asOnDateValue.getTime();\n                } else {\n                  return !isNaN(nextDate) && nextDate >= currentDate && nextDate <= nextMonthDate;\n                }\n            }\n            return false;\n        });\n    });\n\n    return imports.lodash.uniqBy(validEncounters, 'individual.uuid').map(encounter => encounter.individual);\n};",
  "description" : "Show count of all cases Was it a court hearing date? : No and Deadline for next step is within 1 month",
  "color" : "#f8f7e7",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "a4bad348-33bf-47b0-998e-92f7fe083e76",
  "id" : 6736,
  "name" : "Cases with non-court next steps scheduled in the next month - Own Data",
  "query" : "'use strict';\n({ params, imports }) => {\n    let UUIDs = params.user.userUUID;\n    let currentDate = new Date();\n    let nextMonthDate = new Date();\n    nextMonthDate.setMonth(currentDate.getMonth() + 1);\n    \n    let filterValues = {\n        natureOfCase: [],\n        themeOfCase:  [],\n        activeStage1: [],\n        activeStage2: [],\n        activeStage3: [],\n        activeStage4: [],\n        activeStage5: [],\n        activeStage6: []\n    };\n    \n    let asOnDateValue = null;\n    \n    if (params.ruleInput) {\n        let asOnDateFilter = params.ruleInput.find(rule => rule.type === \"AsOnDate\");\n        if (asOnDateFilter && asOnDateFilter.filterValue) {\n            let dateInput = new Date(asOnDateFilter.filterValue);\n            asOnDateValue = new Date(dateInput.getFullYear(), dateInput.getMonth(), dateInput.getDate(), 0, 0, 0, 0);\n        }\n    \n        let caseFilters = params.ruleInput.filter(rule => rule.type === \"Concept\");\n    \n        const caseMapping = {\n            'Nature of Case': 'natureOfCase',\n            'Theme of case': 'themeOfCase',\n            'Stage of Active (pre-litigation) - Criminal Prosecution/ Defence fresh filing': 'activeStage1',\n            'Stage of Active (litigation) status - Criminal Prosecution/ Defence fresh filing': 'activeStage2',\n            'Stage of Active (pre-litigation) - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage3',\n            'Stage of Active (litigation) status - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage4',\n            'Stage of Active (pre-litigation)': 'activeStage5',\n            'Stage of Active (litigation) status': 'activeStage6'\n        };\n    \n        for (let i = 0; i < caseFilters.length; i++) {\n            let filter = caseFilters[i];\n            if (filter.observationBasedFilter && filter.observationBasedFilter.concept) {\n                let key = caseMapping[filter.observationBasedFilter.concept.name];\n                if (key && filter.filterValue) {\n                    filterValues[key] = filter.filterValue.map(add => add.uuid);\n                }\n            }\n        }\n    }\n    \n    function buildQueryCondition(uuid, filterArray, observationType = 'individual.enrolments.observations') {\n        if (filterArray.length === 0) return \"\";\n        let conditions = filterArray.map(uuid => `$observation.valueJSON CONTAINS '${uuid}'`).join(' OR ');\n        return ` \n          AND SUBQUERY(${observationType}, $observation,\n            $observation.concept.uuid = '${uuid}' \n            AND (${conditions})\n          ).@count > 0`;\n    }\n    \n    let query = `individual.voided = false`;\n    \n    query += buildQueryCondition('252f4c55-d113-4951-8ebb-eed01b9ccbb9', filterValues.natureOfCase);\n    query += buildQueryCondition('05865e79-c454-47c2-af03-fc719213b576', filterValues.themeOfCase, 'individual.observations');\n    query += buildQueryCondition('e1945ebb-19df-4055-b9c2-9fbcda959671', filterValues.activeStage1);\n    query += buildQueryCondition('ee698620-9b14-4379-a7de-6098c9f009b0', filterValues.activeStage2);\n    query += buildQueryCondition('c4d9571c-1f78-45d7-a415-83589595ae9d', filterValues.activeStage3);\n    query += buildQueryCondition('aa7cfb95-21f2-48fb-9c28-e6a46c3d88a8', filterValues.activeStage4);\n    query += buildQueryCondition('c8bafd78-6fdf-48ac-bd54-f180b00ce46f', filterValues.activeStage5);\n    query += buildQueryCondition('065e005a-3203-4192-91ad-37e55480a695', filterValues.activeStage6);\n    \n    \n    let encounters = params.db.objects(\"Encounter\")\n    .filtered(query) \n    .filtered(`\n        encounterType.name = 'Case Activity Register' \n        AND voided = false\n        AND individual.voided = false\n        AND SUBQUERY(observations, $obs,\n            $obs.concept.uuid = '12003b39-078c-4f63-aa93-ecfb2e774557'\n            AND $obs.valueJSON CONTAINS '03ead610-1596-4a1f-b57d-07792c6e66b6'\n        ).@count > 0 \n        AND (createdByUUID == NULL OR createdByUUID = $0)\n    `, UUIDs);\n    \n    let validEncounters = encounters.filter(encounter => {\n        return encounter.observations.some(obs => {\n            if (obs.concept.uuid === '3fe8e744-2225-420a-8d00-93f16cacf77b' && obs.valueJSON) {\n                let parsedValue = typeof obs.valueJSON === \"string\" ? JSON.parse(obs.valueJSON) : obs.valueJSON;\n                let dateString = null;\n                if (parsedValue) {\n                    if (parsedValue.answer) {\n                        dateString = parsedValue.answer;\n                    } else if (parsedValue.value) {\n                        dateString = parsedValue.value;\n                    }\n                }\n                if (!dateString) return false;\n                let nextDate = new Date(dateString);\n                if (asOnDateValue) {\n                  return !isNaN(nextDate) && nextDate.getTime() === asOnDateValue.getTime();\n                } else {\n                  return !isNaN(nextDate) && nextDate >= currentDate && nextDate <= nextMonthDate;\n                }\n            }\n            return false;\n        });\n    });\n\n    return imports.lodash.uniqBy(validEncounters, 'individual.uuid').map(encounter => encounter.individual);\n};",
  "description" : "Show count of all cases\nWas it a court hearing date? : No\nand Deadline for next step is within 1 month",
  "color" : "#f8efe7",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "2cf489cb-c117-416a-9ffd-d23271784a99",
  "id" : 6737,
  "name" : "Cases with dates with court dates in the next one month - Own Data",
  "query" : "'use strict';\n({ params, imports }) => {\n    let UUIDs = params.user.userUUID;\n    let currentDate = new Date();\n    let nextMonthDate = new Date();\n    nextMonthDate.setMonth(currentDate.getMonth() + 1);\n    \n    let filterValues = {\n        natureOfCase: [],\n        themeOfCase:  [],\n        activeStage1: [],\n        activeStage2: [],\n        activeStage3: [],\n        activeStage4: [],\n        activeStage5: [],\n        activeStage6: []\n    };\n    \n    let asOnDateValue = null;\n    \n    if (params.ruleInput) {\n        let asOnDateFilter = params.ruleInput.find(rule => rule.type === \"AsOnDate\");\n        if (asOnDateFilter && asOnDateFilter.filterValue) {\n            let dateInput = new Date(asOnDateFilter.filterValue);\n            asOnDateValue = new Date(dateInput.getFullYear(), dateInput.getMonth(), dateInput.getDate(), 0, 0, 0, 0);\n        }\n    \n        let caseFilters = params.ruleInput.filter(rule => rule.type === \"Concept\");\n    \n        const caseMapping = {\n            'Nature of Case': 'natureOfCase',\n            'Theme of case': 'themeOfCase',\n            'Stage of Active (pre-litigation) - Criminal Prosecution/ Defence fresh filing': 'activeStage1',\n            'Stage of Active (litigation) status - Criminal Prosecution/ Defence fresh filing': 'activeStage2',\n            'Stage of Active (pre-litigation) - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage3',\n            'Stage of Active (litigation) status - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage4',\n            'Stage of Active (pre-litigation)': 'activeStage5',\n            'Stage of Active (litigation) status': 'activeStage6'\n        };\n    \n        for (let i = 0; i < caseFilters.length; i++) {\n            let filter = caseFilters[i];\n            if (filter.observationBasedFilter && filter.observationBasedFilter.concept) {\n                let key = caseMapping[filter.observationBasedFilter.concept.name];\n                if (key && filter.filterValue) {\n                    filterValues[key] = filter.filterValue.map(add => add.uuid);\n                }\n            }\n        }\n    }\n  \n    function buildQueryCondition(uuid, filterArray, observationType = 'individual.enrolments.observations') {\n        if (filterArray.length === 0) return \"\";\n        let conditions = filterArray.map(uuid => `$observation.valueJSON CONTAINS '${uuid}'`).join(' OR ');\n        return ` \n          AND SUBQUERY(${observationType}, $observation,\n            $observation.concept.uuid = '${uuid}' \n            AND (${conditions})\n          ).@count > 0`;\n    }\n\n    let query = `individual.voided = false`;\n  \n    query += buildQueryCondition('252f4c55-d113-4951-8ebb-eed01b9ccbb9', filterValues.natureOfCase);\n    query += buildQueryCondition('05865e79-c454-47c2-af03-fc719213b576', filterValues.themeOfCase, 'individual.observations');\n    query += buildQueryCondition('e1945ebb-19df-4055-b9c2-9fbcda959671', filterValues.activeStage1);\n    query += buildQueryCondition('ee698620-9b14-4379-a7de-6098c9f009b0', filterValues.activeStage2);\n    query += buildQueryCondition('c4d9571c-1f78-45d7-a415-83589595ae9d', filterValues.activeStage3);\n    query += buildQueryCondition('aa7cfb95-21f2-48fb-9c28-e6a46c3d88a8', filterValues.activeStage4);\n    query += buildQueryCondition('c8bafd78-6fdf-48ac-bd54-f180b00ce46f', filterValues.activeStage5);\n    query += buildQueryCondition('065e005a-3203-4192-91ad-37e55480a695', filterValues.activeStage6);\n    \n    let encounters = params.db.objects(\"Encounter\")\n    .filtered(query)\n    .filtered(`\n        encounterType.name = 'Case Activity Register' \n        AND voided = false\n        AND individual.voided = false\n        AND SUBQUERY(observations, $obs,\n            $obs.concept.uuid = 'cd8aa6fb-9277-47a5-b082-a70c76d3cc56'\n        ).@count > 0 \n        AND (createdByUUID == NULL OR createdByUUID = $0)\n    `, UUIDs);\n    \n    let validEncounters = encounters.filter(encounter => {\n        return encounter.observations.some(obs => {\n            if (obs.concept.uuid === 'cd8aa6fb-9277-47a5-b082-a70c76d3cc56' && obs.valueJSON) {\n                let parsedValue = typeof obs.valueJSON === \"string\" ? JSON.parse(obs.valueJSON) : obs.valueJSON;\n                \n                let dateString = null;\n                if (parsedValue) {\n                    if (parsedValue.answer) {\n                        dateString = parsedValue.answer;\n                    } else if (parsedValue.value) {\n                        dateString = parsedValue.value;\n                    }\n                }\n                if (!dateString) return false;\n                let nextDate = new Date(dateString);\n                if (asOnDateValue) {\n                  return !isNaN(nextDate) && nextDate.getTime() === asOnDateValue.getTime();\n                } else {\n                  return !isNaN(nextDate) && nextDate >= currentDate && nextDate <= nextMonthDate;\n                }\n            }\n            return false;\n        });\n    });\n\n    return imports.lodash.uniqBy(validEncounters, 'individual.uuid').map(encounter => encounter.individual);\n};",
  "description" : "",
  "color" : "#e6eefa",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "74e10e29-f266-4a51-a3f4-07fffaa199ac",
  "id" : 6738,
  "name" : "FF conversion  - Other Field Workers data \n",
  "query" : "'use strict';\n({ params, imports }) => {\n    let UUIDs = params.user.userUUID;\n    let currentDate = new Date();\n    let nextMonthDate = new Date();\n    nextMonthDate.setMonth(currentDate.getMonth() + 1);\n    \n    let filterValues = {\n        natureOfCase: [],\n        activeStage1: [],\n        activeStage2: [],\n        activeStage3: [],\n        activeStage4: [],\n        activeStage5: [],\n        activeStage6: []\n    };\n    \n    if (params.ruleInput) {\n        let caseFilters = params.ruleInput.filter(rule => rule.type === \"Concept\");\n        const caseMapping = {\n            'Nature of Case': 'natureOfCase',\n            'Theme of case': 'themeOfCase',\n            'Stage of Active (pre-litigation) - Criminal Prosecution/ Defence fresh filing': 'activeStage1',\n            'Stage of Active (litigation) status - Criminal Prosecution/ Defence fresh filing': 'activeStage2',\n            'Stage of Active (pre-litigation) - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage3',\n            'Stage of Active (litigation) status - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage4',\n            'Stage of Active (pre-litigation)': 'activeStage5',\n            'Stage of Active (litigation) status': 'activeStage6'\n        };\n    \n        for (let i = 0; i < caseFilters.length; i++) {\n            let filter = caseFilters[i];\n            if (filter.observationBasedFilter && filter.observationBasedFilter.concept) {\n                let key = caseMapping[filter.observationBasedFilter.concept.name];\n                if (key && filter.filterValue) {\n                    filterValues[key] = filter.filterValue.map(add => add.uuid);\n                }\n            }\n        }\n    }\n    \n    function buildQueryCondition(uuid, filterArray) {\n        if (filterArray.length === 0) return \"\";\n        let conditions = filterArray.map(uuid => `$observation.valueJSON CONTAINS '${uuid}'`).join(' OR ');\n        return ` \n          SUBQUERY(observations, $observation,\n            $observation.concept.uuid = '${uuid}' \n            AND (${conditions})\n          ).@count > 0`;\n    }\n\n    let queryConditions = [];\n\n    queryConditions.push(\"voided == false\");\n    \n    queryConditions.push(buildQueryCondition('252f4c55-d113-4951-8ebb-eed01b9ccbb9', filterValues.natureOfCase));\n    queryConditions.push(buildQueryCondition('e1945ebb-19df-4055-b9c2-9fbcda959671', filterValues.activeStage1));\n    queryConditions.push(buildQueryCondition('ee698620-9b14-4379-a7de-6098c9f009b0', filterValues.activeStage2));\n    queryConditions.push(buildQueryCondition('c4d9571c-1f78-45d7-a415-83589595ae9d', filterValues.activeStage3));\n    queryConditions.push(buildQueryCondition('aa7cfb95-21f2-48fb-9c28-e6a46c3d88a8', filterValues.activeStage4));\n    queryConditions.push(buildQueryCondition('c8bafd78-6fdf-48ac-bd54-f180b00ce46f', filterValues.activeStage5));\n    queryConditions.push(buildQueryCondition('065e005a-3203-4192-91ad-37e55480a695', filterValues.activeStage6));\n    queryConditions = queryConditions.filter(condition => condition.trim() !== \"\");\n    \n    let query = queryConditions.join(\" AND \");\n    \n    \n    let enrolments = params.db.objects(\"ProgramEnrolment\")\n    .filtered(query)\n    .filtered(`\n      program.name = 'Case Status' \n      AND individual.voided = false\n      AND SUBQUERY(observations, $observation,\n        $observation.concept.uuid = '252f4c55-d113-4951-8ebb-eed01b9ccbb9' \n        AND (\n          $observation.valueJSON CONTAINS 'a3d1b65d-0e00-4e78-9cf2-0bbd29e77642' \n          OR $observation.valueJSON CONTAINS '0fc2f7cb-ab3e-4474-8d85-c4e40917409f'\n        )  \n      ).@count > 0 \n      AND SUBQUERY(observations, $observation2,\n        $observation2.concept.uuid = 'b1927aeb-ab4c-46a6-8eff-6ccdf38f5478' \n        AND $observation2.valueJSON CONTAINS 'b5d60cc0-716a-4980-ac26-13559bfb31ac'\n      ).@count > 0\n      AND (createdByUUID == NULL OR createdByUUID != $0)`\n    , UUIDs);\n  \n    let encounters = params.db.objects(\"Encounter\").filtered(`\n        encounterType.name = 'Case Fact Finding' \n        AND voided = false\n        AND individual.voided = false\n        AND encounterDateTime != null \n        AND (createdByUUID == NULL OR createdByUUID != $0)\n    `, UUIDs);\n    \n    let enrolmentArray = enrolments.map(enrl => ({\n        individual: enrl.individual,\n        enrolmentDateTime: enrl.enrolmentDateTime\n    }));\n    \n    let encounterArray = encounters.map(enc => ({\n        individual: enc.individual,\n        encounterDateTime: enc.encounterDateTime\n    }));\n    \n    let ninetyDaysAgo = new Date();\n    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);\n    \n    let result = enrolmentArray.filter(enrl => {\n        let matchedEncounters = encounterArray.filter(enc => \n            enc.individual.uuid === enrl.individual.uuid &&\n            new Date(enrl.enrolmentDateTime) < ninetyDaysAgo\n        );\n        return matchedEncounters.length > 0;\n    }).map(enrl => enrl.individual);\n    \n    return result;\n};",
  "description" : "Nature of the case :  Criminal prosecution fresh filing  or Criminal defence fresh filing\nStatus of case is in \" Active (pre-litigation)\" for more than 90days\nand Fact Finding form for these cases are filled",
  "color" : "#89fae2",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "aec690c9-4937-43fd-9bd0-23d1dcde9e32",
  "id" : 6739,
  "name" : "Cases with dates with court dates in the next one month - Other Field Workers data ",
  "query" : "'use strict';\n({ params, imports }) => {\n    let UUIDs = params.user.userUUID;\n    let currentDate = new Date();\n    let nextMonthDate = new Date();\n    nextMonthDate.setMonth(currentDate.getMonth() + 1);\n    \n    let filterValues = {\n        natureOfCase: [],\n        themeOfCase:  [],\n        activeStage1: [],\n        activeStage2: [],\n        activeStage3: [],\n        activeStage4: [],\n        activeStage5: [],\n        activeStage6: []\n    };\n    \n    let asOnDateValue = null;\n    \n    if (params.ruleInput) {\n        let asOnDateFilter = params.ruleInput.find(rule => rule.type === \"AsOnDate\");\n        if (asOnDateFilter && asOnDateFilter.filterValue) {\n            let dateInput = new Date(asOnDateFilter.filterValue);\n            asOnDateValue = new Date(dateInput.getFullYear(), dateInput.getMonth(), dateInput.getDate(), 0, 0, 0, 0);\n        }\n    \n        let caseFilters = params.ruleInput.filter(rule => rule.type === \"Concept\");\n  \n        const caseMapping = {\n            'Nature of Case': 'natureOfCase',\n            'Theme of case': 'themeOfCase',\n            'Stage of Active (pre-litigation) - Criminal Prosecution/ Defence fresh filing': 'activeStage1',\n            'Stage of Active (litigation) status - Criminal Prosecution/ Defence fresh filing': 'activeStage2',\n            'Stage of Active (pre-litigation) - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage3',\n            'Stage of Active (litigation) status - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage4',\n            'Stage of Active (pre-litigation)': 'activeStage5',\n            'Stage of Active (litigation) status': 'activeStage6'\n        };\n    \n        for (let i = 0; i < caseFilters.length; i++) {\n            let filter = caseFilters[i];\n            if (filter.observationBasedFilter && filter.observationBasedFilter.concept) {\n                let key = caseMapping[filter.observationBasedFilter.concept.name];\n                if (key && filter.filterValue) {\n                    filterValues[key] = filter.filterValue.map(add => add.uuid);\n                }\n            }\n        }\n    }\n    \n    function buildQueryCondition(uuid, filterArray, observationType = 'individual.enrolments.observations') {\n        if (filterArray.length === 0) return \"\";\n        let conditions = filterArray.map(uuid => `$observation.valueJSON CONTAINS '${uuid}'`).join(' OR ');\n        return ` \n          AND SUBQUERY(${observationType}, $observation,\n            $observation.concept.uuid = '${uuid}' \n            AND (${conditions})\n          ).@count > 0`;\n    }\n\n    let query = `individual.voided = false`;\n    \n    query += buildQueryCondition('252f4c55-d113-4951-8ebb-eed01b9ccbb9', filterValues.natureOfCase);\n    query += buildQueryCondition('05865e79-c454-47c2-af03-fc719213b576', filterValues.themeOfCase, 'individual.observations');\n    query += buildQueryCondition('e1945ebb-19df-4055-b9c2-9fbcda959671', filterValues.activeStage1);\n    query += buildQueryCondition('ee698620-9b14-4379-a7de-6098c9f009b0', filterValues.activeStage2);\n    query += buildQueryCondition('c4d9571c-1f78-45d7-a415-83589595ae9d', filterValues.activeStage3);\n    query += buildQueryCondition('aa7cfb95-21f2-48fb-9c28-e6a46c3d88a8', filterValues.activeStage4);\n    query += buildQueryCondition('c8bafd78-6fdf-48ac-bd54-f180b00ce46f', filterValues.activeStage5);\n    query += buildQueryCondition('065e005a-3203-4192-91ad-37e55480a695', filterValues.activeStage6);\n\n    let encounters = params.db.objects(\"Encounter\")\n    .filtered(query)\n    .filtered(`\n        encounterType.name = 'Case Activity Register' \n        AND voided = false\n        AND individual.voided = false\n        AND SUBQUERY(observations, $obs,\n            $obs.concept.uuid = 'cd8aa6fb-9277-47a5-b082-a70c76d3cc56'\n        ).@count > 0 \n        AND (createdByUUID == NULL OR createdByUUID != $0)\n    `, UUIDs);\n    \n    let validEncounters = encounters.filter(encounter => {\n        return encounter.observations.some(obs => {\n            if (obs.concept.uuid === 'cd8aa6fb-9277-47a5-b082-a70c76d3cc56' && obs.valueJSON) {\n                let parsedValue = typeof obs.valueJSON === \"string\" ? JSON.parse(obs.valueJSON) : obs.valueJSON;\n                \n                let dateString = null;\n                if (parsedValue) {\n                    if (parsedValue.answer) {\n                        dateString = parsedValue.answer;\n                    } else if (parsedValue.value) {\n                        dateString = parsedValue.value;\n                    }\n                }\n                if (!dateString) return false;\n                let nextDate = new Date(dateString);\n                if (asOnDateValue) {\n                  return !isNaN(nextDate) && nextDate.getTime() === asOnDateValue.getTime();\n                } else {\n                  return !isNaN(nextDate) && nextDate >= currentDate && nextDate <= nextMonthDate;\n                }\n            }\n            return false;\n        });\n    });\n    \n    return imports.lodash.uniqBy(validEncounters, 'individual.uuid').map(encounter => encounter.individual);\n};",
  "description" : "",
  "color" : "#ebe7f8",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "3539ddd9-533a-4b74-b530-9c1dbb4b3aae",
  "id" : 6740,
  "name" : "Total cases where fact finding has not converted to court case",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({ params, imports }) => {\n    let UUIDs = params.user.userUUID;\n    let currentDate = new Date();\n    let nextMonthDate = new Date();\n    nextMonthDate.setMonth(currentDate.getMonth() + 1);\n    \n    let filterValues = {\n        natureOfCase: [],\n        activeStage1: [],\n        activeStage2: [],\n        activeStage3: [],\n        activeStage4: [],\n        activeStage5: [],\n        activeStage6: [],\n        applicantName: ''\n    };\n    \n    if (params.ruleInput) {\n        let caseFilters = params.ruleInput.filter(rule => rule.type === \"Concept\");\n        const caseMapping = {\n            'Nature of Case': 'natureOfCase',\n            'Theme of case': 'themeOfCase',\n            'Stage of Active (pre-litigation) - Criminal Prosecution/ Defence fresh filing': 'activeStage1',\n            'Stage of Active (litigation) status - Criminal Prosecution/ Defence fresh filing': 'activeStage2',\n            'Stage of Active (pre-litigation) - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage3',\n            'Stage of Active (litigation) status - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage4',\n            'Stage of Active (pre-litigation)': 'activeStage5',\n            'Stage of Active (litigation) status': 'activeStage6',\n            'Name of applicant': 'applicantName'\n        };\n    \n        for (let i = 0; i < caseFilters.length; i++) {\n            let filter = caseFilters[i];\n            if (filter.observationBasedFilter && filter.observationBasedFilter.concept) {\n                const conceptName = filter.observationBasedFilter.concept.name;\n                if (conceptName === 'Name of applicant' && filter.filterValue) {\n                    filterValues.applicantName = Array.isArray(filter.filterValue) ? \n                        (filter.filterValue[0] && filter.filterValue[0].value) || '' : \n                        filter.filterValue;\n                } else {\n                    let key = caseMapping[conceptName];\n                    if (key && filter.filterValue) {\n                        filterValues[key] = filter.filterValue.map(add => add.uuid || add);\n                    }\n                }\n            }\n        }\n    }\n    \n    function buildQueryCondition(uuid, filterArray) {\n        if (filterArray.length === 0) return \"\";\n        let conditions = filterArray.map(uuid => `$observation.valueJSON CONTAINS '${uuid}'`).join(' OR ');\n        return ` \n          SUBQUERY(observations, $observation,\n            $observation.concept.uuid = '${uuid}' \n            AND (${conditions})\n          ).@count > 0`;\n    }\n    \n    let queryConditions = [];\n\n    queryConditions.push(\"voided == false\");\n    \n    queryConditions.push(buildQueryCondition('252f4c55-d113-4951-8ebb-eed01b9ccbb9', filterValues.natureOfCase));\n    queryConditions.push(buildQueryCondition('e1945ebb-19df-4055-b9c2-9fbcda959671', filterValues.activeStage1));\n    queryConditions.push(buildQueryCondition('ee698620-9b14-4379-a7de-6098c9f009b0', filterValues.activeStage2));\n    queryConditions.push(buildQueryCondition('c4d9571c-1f78-45d7-a415-83589595ae9d', filterValues.activeStage3));\n    queryConditions.push(buildQueryCondition('aa7cfb95-21f2-48fb-9c28-e6a46c3d88a8', filterValues.activeStage4));\n    queryConditions.push(buildQueryCondition('c8bafd78-6fdf-48ac-bd54-f180b00ce46f', filterValues.activeStage5));\n    queryConditions.push(buildQueryCondition('065e005a-3203-4192-91ad-37e55480a695', filterValues.activeStage6));\n    queryConditions = queryConditions.filter(condition => condition.trim() !== \"\");\n    \n    // Add name filter condition if provided\n    if (filterValues.applicantName) {\n        queryConditions.push(`\n          SUBQUERY(individual.observations, $nameObs,\n            $nameObs.concept.uuid = 'a166f8fb-a245-4c2a-ad0b-a9eac2dc0b8d'\n            AND $nameObs.valueJSON CONTAINS[c] '${filterValues.applicantName}'\n          ).@count > 0`);\n    }\n\n    let query = queryConditions.filter(Boolean).join(\" AND \");\n    \n    let enrolments = params.db.objects(\"ProgramEnrolment\")\n    .filtered(query)\n    .filtered(`\n      program.name = 'Case Status' \n      AND individual.voided = false\n      AND SUBQUERY(observations, $observation,\n        $observation.concept.uuid = '252f4c55-d113-4951-8ebb-eed01b9ccbb9' \n        AND (\n          $observation.valueJSON CONTAINS 'a3d1b65d-0e00-4e78-9cf2-0bbd29e77642' \n          OR $observation.valueJSON CONTAINS '0fc2f7cb-ab3e-4474-8d85-c4e40917409f'\n        )  \n      ).@count > 0 \n      AND SUBQUERY(observations, $observation2,\n        $observation2.concept.uuid = 'b1927aeb-ab4c-46a6-8eff-6ccdf38f5478' \n        AND $observation2.valueJSON CONTAINS 'b5d60cc0-716a-4980-ac26-13559bfb31ac'\n      ).@count > 0\n      AND (createdByUUID == NULL OR createdByUUID == $0)`\n    , UUIDs);\n  \n    let encounters = params.db.objects(\"Encounter\").filtered(`\n        encounterType.name = 'Case Fact Finding' \n        AND voided = false\n        AND individual.voided = false\n        AND encounterDateTime != null \n        AND (createdByUUID == NULL OR createdByUUID == $0)\n    `, UUIDs);\n    \n    let enrolmentArray = enrolments.map(enrl => ({\n        individual: enrl.individual,\n        enrolmentDateTime: enrl.enrolmentDateTime\n    }));\n    \n    let encounterArray = encounters.map(enc => ({\n        individual: enc.individual,\n        encounterDateTime: enc.encounterDateTime\n    }));\n    \n    let ninetyDaysAgo = new Date();\n    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);\n    \n    let result = enrolmentArray.filter(enrl => {\n        const enrolmentDate = new Date(enrl.enrolmentDateTime);\n      \n        if (enrolmentDate >= ninetyDaysAgo) {\n            return false;\n        }\n        let matchedEncounters = encounterArray.filter(enc => \n            enc.individual.uuid === enrl.individual.uuid\n        );\n        const hasEncounters = matchedEncounters.length > 0;\n        return hasEncounters;\n    }).map(enrl => enrl.individual);\n  \n    return result;\n};",
  "description" : "Nature of the case :  Criminal prosecution fresh filing  or Criminal defence fresh filing\nStatus of case is in \" Active (pre-litigation)\" for more than 90days\nand Fact Finding form for these cases are filled",
  "color" : "#ebf8e7",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "9e436998-101d-4b97-b8de-a24fa59e9e85",
  "id" : 6741,
  "name" : "No. of total Active Cases - Other Field Workers data \n",
  "query" : "'use strict';\n({params, imports}) => {\n    let UUIDs = params.user.userUUID;\n    \n    let filterValues = {\n        natureOfCase: [],\n        activeStage1: [],\n        activeStage2: [],\n        activeStage3: [],\n        activeStage4: [],\n        activeStage5: [],\n        activeStage6: []\n    };\n    \n    if (params.ruleInput) {\n        let caseFilters = params.ruleInput.filter(rule => rule.type === \"Concept\");\n        const caseMapping = {\n            'Nature of Case': 'natureOfCase',\n            'Theme of case': 'themeOfCase',\n            'Stage of Active (pre-litigation) - Criminal Prosecution/ Defence fresh filing': 'activeStage1',\n            'Stage of Active (litigation) status - Criminal Prosecution/ Defence fresh filing': 'activeStage2',\n            'Stage of Active (pre-litigation) - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage3',\n            'Stage of Active (litigation) status - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage4',\n            'Stage of Active (pre-litigation)': 'activeStage5',\n            'Stage of Active (litigation) status': 'activeStage6'\n        };\n    \n        for (let i = 0; i < caseFilters.length; i++) {\n            let filter = caseFilters[i];\n            if (filter.observationBasedFilter && filter.observationBasedFilter.concept) {\n                let key = caseMapping[filter.observationBasedFilter.concept.name];\n                if (key && filter.filterValue) {\n                    filterValues[key] = filter.filterValue.map(add => add.uuid);\n                }\n            }\n        }\n    }\n        \n    function buildQueryCondition(uuid, filterArray) {\n        if (filterArray.length === 0) return \"\";\n        let conditions = filterArray.map(uuid => `$observation.valueJSON CONTAINS '${uuid}'`).join(' OR ');\n        return ` \n          AND SUBQUERY(observations, $observation,\n            $observation.concept.uuid = '${uuid}' \n            AND (${conditions})\n          ).@count > 0`;\n    }\n\n    let query = `voided = false`;\n  \n    query += buildQueryCondition('252f4c55-d113-4951-8ebb-eed01b9ccbb9', filterValues.natureOfCase);\n    query += buildQueryCondition('e1945ebb-19df-4055-b9c2-9fbcda959671', filterValues.activeStage1);\n    query += buildQueryCondition('ee698620-9b14-4379-a7de-6098c9f009b0', filterValues.activeStage2);\n    query += buildQueryCondition('c4d9571c-1f78-45d7-a415-83589595ae9d', filterValues.activeStage3);\n    query += buildQueryCondition('aa7cfb95-21f2-48fb-9c28-e6a46c3d88a8', filterValues.activeStage4);\n    query += buildQueryCondition('c8bafd78-6fdf-48ac-bd54-f180b00ce46f', filterValues.activeStage5);\n    query += buildQueryCondition('065e005a-3203-4192-91ad-37e55480a695', filterValues.activeStage6);\n    \n    let caseStatus = params.db.objects(\"ProgramEnrolment\")\n    .filtered(query)\n    .filtered(`\n      program.name = 'Case Status' \n      AND programExitDateTime = null \n      AND individual.voided = false\n      AND SUBQUERY(observations, $observation,\n            $observation.concept.uuid = 'b1927aeb-ab4c-46a6-8eff-6ccdf38f5478' AND\n            (\n              $observation.valueJSON CONTAINS '65688e86-a632-4e70-9ef8-4f19b0fc3bee' \n              OR \n              $observation.valueJSON CONTAINS 'd56b69db-da83-4f60-9a3f-4cc159e5e191'\n            )\n      ).@count == 0 AND (createdByUUID = NULL OR createdByUUID != $0) AND ${query}`,UUIDs\n    ).map((enrl) => enrl.individual);\n    \n    return caseStatus;\n};",
  "description" : "",
  "color" : "#ffc700",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "08148569-c29c-4b4e-8a2d-d41a50292270",
  "id" : 6742,
  "name" : "Internal Trainings - Own Data",
  "query" : "'use strict';\n\n({ params, imports }) => {\n    let UUIDs = params.user.userUUID;\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n    let queryParams = [UUIDs]; // Start with user UUID\n\n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type === \"Address\");\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            addressValue = addressFilter[0].filterValue\n                .filter(add => add.type === \"Administrative Unit\")\n                .map(add => add.name);\n        }\n\n        let rangeDateFilter = params.ruleInput.filter(rule => rule.type === \"RegistrationDate\");\n        if (rangeDateFilter.length > 0 && rangeDateFilter[0].filterValue) {\n            let minDateInput = new Date(rangeDateFilter[0].filterValue.minValue);\n            let maxDateInput = new Date(rangeDateFilter[0].filterValue.maxValue);\n\n            minDateValue = new Date(minDateInput.getFullYear(), minDateInput.getMonth(), minDateInput.getDate(), 0, 0, 0, 0);\n            maxDateValue = new Date(maxDateInput.getFullYear(), maxDateInput.getMonth(), maxDateInput.getDate(), 23, 59, 59, 999);\n        }\n    }\n\n    let query = `\n        individual.voided = false \n        AND encounterType.name = \"Internal Training\"\n        AND cancelDateTime = NULL \n        AND (createdByUUID = NULL OR createdByUUID = $0)\n    `;\n\n    if (minDateValue && maxDateValue) {\n        query += ` AND encounterDateTime >= $${queryParams.length} AND encounterDateTime <= $${queryParams.length + 1}`;\n        queryParams.push(minDateValue, maxDateValue);\n    }\n    \n    if (addressValue.length > 0) {\n        query += ` AND individual.lowestAddressLevel.name IN $${queryParams.length}`;\n        queryParams.push(addressValue);\n    }\n\n    let internalTraining = params.db.objects('Encounter').filtered(query, ...queryParams);\n\n    return {\n        primaryValue: internalTraining.length,\n        lineListFunction: () => internalTraining.map(enc => enc.individual)\n    };\n};",
  "description" : "",
  "color" : "#f8efe7",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "7fbc8c67-f52a-42db-b501-06bcc4ad988d",
  "id" : 6743,
  "name" : "Outreach Client Registration Follow-Ups Due - Other Field Workers data",
  "query" : "'use strict';\n({ params, imports }) => {\n    let userUUID = params.user.userUUID;\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n\n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type == \"Address\");\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            addressValue = addressFilter[0].filterValue\n                .filter(add => add.type == \"Administrative Unit\")\n                .map(add => add.uuid);\n        }\n\n        let rangeDateFilter = params.ruleInput.filter(rule => rule.type == \"RegistrationDate\");\n        if (rangeDateFilter.length > 0 && rangeDateFilter[0].filterValue) {\n            let minDateInput = new Date(rangeDateFilter[0].filterValue.minValue);\n            let maxDateInput = new Date(rangeDateFilter[0].filterValue.maxValue);\n            \n            minDateValue = new Date(minDateInput.getFullYear(), minDateInput.getMonth(), minDateInput.getDate(), 0, 0, 0, 0);\n            maxDateValue = new Date(maxDateInput.getFullYear(), maxDateInput.getMonth(), maxDateInput.getDate(), 23, 59, 59, 999);\n        }\n    }\n\n    let query = `\n        voided = false \n        AND subjectType.name = 'Outreach Client Registration – Issues Identified'\n        AND SUBQUERY(observations, $observation2,\n          $observation2.concept.uuid = 'e26a61db-d7bf-4fbe-b5e2-ed60294e8f62' \n          AND $observation2.valueJSON CONTAINS '271a0678-be07-4802-b228-92e1cfd8c56e'\n        ).@count > 0\n    `;\n\n    if (addressValue.length > 0) {\n        let output = addressValue.map(item => `'${item}'`).join(\", \");\n        query += ` AND lowestAddressLevel.uuid IN {${output}}`;\n    }\n\n    if (minDateValue && maxDateValue) {\n        query += ` AND registrationDate >= $1 AND registrationDate <= $2`;\n    }\n\n    query += ` AND (createdByUUID == NULL OR createdByUUID != $0)`;\n\n    return params.db.objects('Individual')\n        .filtered(query, userUUID, minDateValue, maxDateValue);\n};",
  "description" : "",
  "color" : "#f8efe7",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "5e210780-5f86-4f49-8d72-2f0404f5d70c",
  "id" : 6744,
  "name" : "active case",
  "query" : "'use strict';\n({params, imports}) => {\n    let UUIDs = params.user.userUUID;\n    \n    let filterValues = {\n        natureOfCase: [],\n        activeStage1: [],\n        activeStage2: [],\n        activeStage3: [],\n        activeStage4: [],\n        activeStage5: [],\n        activeStage6: []\n    };\n    \n    if (params.ruleInput) {\n        let caseFilters = params.ruleInput.filter(rule => rule.type === \"Concept\");\n        const caseMapping = {\n            'Nature of Case': 'natureOfCase',\n            'Theme of case': 'themeOfCase',\n            'Stage of Active (pre-litigation) - Criminal Prosecution/ Defence fresh filing': 'activeStage1',\n            'Stage of Active (litigation) status - Criminal Prosecution/ Defence fresh filing': 'activeStage2',\n            'Stage of Active (pre-litigation) - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage3',\n            'Stage of Active (litigation) status - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage4',\n            'Stage of Active (pre-litigation)': 'activeStage5',\n            'Stage of Active (litigation) status': 'activeStage6'\n        };\n    \n        for (let i = 0; i < caseFilters.length; i++) {\n            let filter = caseFilters[i];\n            if (filter.observationBasedFilter && filter.observationBasedFilter.concept) {\n                let key = caseMapping[filter.observationBasedFilter.concept.name];\n                if (key && filter.filterValue) {\n                    filterValues[key] = filter.filterValue.map(add => add.uuid);\n                }\n            }\n        }\n    }\n    \n    function buildQueryCondition(uuid, filterArray) {\n        if (filterArray.length === 0) return \"\";\n        let conditions = filterArray.map(uuid => `$observation.valueJSON CONTAINS '${uuid}'`).join(' OR ');\n        return ` \n          AND SUBQUERY(observations, $observation,\n            $observation.concept.uuid = '${uuid}' \n            AND (${conditions})\n          ).@count > 0`;\n    }\n\n    let query = `voided = false`;\n  \n    query += buildQueryCondition('252f4c55-d113-4951-8ebb-eed01b9ccbb9', filterValues.natureOfCase);\n    query += buildQueryCondition('e1945ebb-19df-4055-b9c2-9fbcda959671', filterValues.activeStage1);\n    query += buildQueryCondition('ee698620-9b14-4379-a7de-6098c9f009b0', filterValues.activeStage2);\n    query += buildQueryCondition('c4d9571c-1f78-45d7-a415-83589595ae9d', filterValues.activeStage3);\n    query += buildQueryCondition('aa7cfb95-21f2-48fb-9c28-e6a46c3d88a8', filterValues.activeStage4);\n    query += buildQueryCondition('c8bafd78-6fdf-48ac-bd54-f180b00ce46f', filterValues.activeStage5);\n    query += buildQueryCondition('065e005a-3203-4192-91ad-37e55480a695', filterValues.activeStage6);\n    \n    let caseStatus = params.db.objects(\"ProgramEnrolment\")\n    .filtered(query)\n    .filtered(`\n      program.name = 'Case Status' \n      AND programExitDateTime = null \n      AND individual.voided = false\n      AND SUBQUERY(observations, $observation,\n            $observation.concept.uuid = 'b1927aeb-ab4c-46a6-8eff-6ccdf38f5478' AND\n            (\n                  $observation.valueJSON CONTAINS 'b5d60cc0-716a-4980-ac26-13559bfb31ac' \n            )\n      ).@count > 0 AND createdByUUID = $0`,UUIDs\n    ).map((enrl) => enrl.individual);\n    \n    return caseStatus;\n};",
  "description" : "",
  "color" : "#e5d2be",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "daa9f02f-e63a-48b4-a135-77a7491420f7",
  "id" : 6745,
  "name" : "Total active pre lit case",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({params, imports}) => {\n    let UUIDs = params.user.userUUID;\n    \n    let filterValues = {\n        natureOfCase: [],\n        activeStage1: [],\n        activeStage2: [],\n        activeStage3: [],\n        activeStage4: [],\n        activeStage5: [],\n        activeStage6: [],\n        applicantName: ''\n    };\n    \n    if (params.ruleInput) {\n        let caseFilters = params.ruleInput.filter(rule => rule.type === \"Concept\");\n        const caseMapping = {\n            'Nature of Case': 'natureOfCase',\n            'Theme of case': 'themeOfCase',\n            'Stage of Active (pre-litigation) - Criminal Prosecution/ Defence fresh filing': 'activeStage1',\n            'Stage of Active (litigation) status - Criminal Prosecution/ Defence fresh filing': 'activeStage2',\n            'Stage of Active (pre-litigation) - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage3',\n            'Stage of Active (litigation) status - Civil / revenue / labour / consumer / family etc. fresh filing': 'activeStage4',\n            'Stage of Active (pre-litigation)': 'activeStage5',\n            'Stage of Active (litigation) status': 'activeStage6'\n        };\n    \n        for (let i = 0; i < caseFilters.length; i++) {\n            let filter = caseFilters[i];\n            if (filter.observationBasedFilter && filter.observationBasedFilter.concept) {\n                const conceptName = filter.observationBasedFilter.concept.name;\n                if (conceptName === 'Name of applicant' && filter.filterValue) {\n                    filterValues.applicantName = filter.filterValue;\n                } else {\n                    let key = caseMapping[conceptName];\n                    if (key && filter.filterValue) {\n                        filterValues[key] = filter.filterValue.map(add => add.uuid);\n                    }\n                }\n            }\n        }\n    }\n    \n    function buildQueryCondition(uuid, filterArray) {\n        if (filterArray.length === 0) return \"\";\n        const conditions = filterArray.map(uuid => `$observation.valueJSON CONTAINS '${uuid}'`).join(' OR ');\n        return `\n          AND SUBQUERY(observations, $observation,\n            $observation.concept.uuid = '${uuid}'\n            AND (${conditions})\n          ).@count > 0`;\n    }\n\n    let query = `voided = false`;\n  \n    query += buildQueryCondition('252f4c55-d113-4951-8ebb-eed01b9ccbb9', filterValues.natureOfCase);\n    query += buildQueryCondition('e1945ebb-19df-4055-b9c2-9fbcda959671', filterValues.activeStage1);\n    query += buildQueryCondition('ee698620-9b14-4379-a7de-6098c9f009b0', filterValues.activeStage2);\n    query += buildQueryCondition('c4d9571c-1f78-45d7-a415-83589595ae9d', filterValues.activeStage3);\n    query += buildQueryCondition('aa7cfb95-21f2-48fb-9c28-e6a46c3d88a8', filterValues.activeStage4);\n    query += buildQueryCondition('c8bafd78-6fdf-48ac-bd54-f180b00ce46f', filterValues.activeStage5);\n    query += buildQueryCondition('065e005a-3203-4192-91ad-37e55480a695', filterValues.activeStage6);\n    if (filterValues.applicantName) {\n        const name = filterValues.applicantName;\n        query += `\n          AND SUBQUERY(individual.observations, $obs,\n            $obs.concept.uuid = 'a166f8fb-a245-4c2a-ad0b-a9eac2dc0b8d'\n            AND $obs.valueJSON CONTAINS[c] '${name}'\n          ).@count > 0`;\n    }\n    \n    let caseStatus = params.db.objects(\"ProgramEnrolment\")\n    .filtered(query)\n    .filtered(`\n      program.name = 'Case Status' \n      AND programExitDateTime = null \n      AND individual.voided = false\n      AND SUBQUERY(observations, $observation,\n            $observation.concept.uuid = 'b1927aeb-ab4c-46a6-8eff-6ccdf38f5478' AND\n            (\n                  $observation.valueJSON CONTAINS 'b5d60cc0-716a-4980-ac26-13559bfb31ac' \n            )\n      ).@count > 0 AND createdByUUID = $0`,UUIDs\n    ).map((enrl) => enrl.individual);\n    \n    return caseStatus;\n};",
  "description" : "",
  "color" : "#e6eefa",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "60cca34e-29a6-43c1-880e-08667b07d308",
  "id" : 6747,
  "name" : "No. of External Trainings-Catchment Data",
  "query" : "'use strict';\n({ params, imports, db }) => {\n    const now = new Date();\n    const currentMonth = now.getMonth();\n    const currentYear = now.getFullYear();\n    const financialYearEnd = currentMonth < 3 ? currentYear - 1 : currentYear;\n    const financialYearStart = financialYearEnd - 1;\n    const minDate = new Date(financialYearStart, 3, 1);\n    const maxDate = new Date(financialYearEnd, 2, 31, 23, 59, 59, 999);\n\n    const encounters = params.db.objects('Encounter').filtered(`\n        voided = false \n        AND encounterType.name = \"External Training\"\n        AND cancelDateTime = NULL\n        AND encounterDateTime >= $0 \n        AND encounterDateTime <= $1\n    `, minDate, maxDate);\n\n    const individualMap = new Map();\n    \n    encounters.forEach(enc => {\n        if (enc.individual) {\n            individualMap.set(enc.individual.uuid, enc.individual);\n        }\n    });\n\n    const uniqueIndividuals = Array.from(individualMap.values());\n\n    return {\n        primaryValue: uniqueIndividuals.length,\n        lineListFunction: () => uniqueIndividuals\n    };\n};",
  "description" : "",
  "color" : "#ffb000",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "f09efaea-c760-4f58-b764-373176a0044f",
  "id" : 6746,
  "name" : "All outreach visits this year-Other Field Workers",
  "query" : "'use strict';\n({ params, imports }) => {\n    let userUUID = params.user.userUUID;\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n    let anyaSthalValues = [];\n    let campaignNameSearch = '';\n    const VISIT_DATE_CONCEPT_UUID = 'ff308558-e951-46bf-8115-c41bf16b02da';\n    const ANYA_STHAL_CONCEPT_UUID = 'd7d0afa3-3b73-4317-94fc-c7b43db62367';\n    const CAMPAIGN_NAME_SEARCH_CONCEPT_UUID = 'e17aba43-433c-43c0-a7e7-d7f5a79ed244';\n    const ADDRESS_DETAILS_CONCEPT_UUID = '35a98d23-f999-4367-976a-22682122901d'; // Address Details - Village\n\n    // Set default to previous financial year (April to March)\n    const now = new Date();\n    const currentYear = now.getFullYear();\n    const currentMonth = now.getMonth();\n    \n    // Default to previous financial year (April 1 to March 31)\nif (currentMonth >= 4) {\n    minDateValue = new Date(currentYear, 3, 1, 0, 0, 0, 0);\n    maxDateValue = new Date(currentYear + 1, 3, 0, 23, 59, 59, 999);\n} else {\n    minDateValue = new Date(currentYear - 1, 3, 1, 0, 0, 0, 0);\n    maxDateValue = new Date(currentYear, 3, 0, 23, 59, 59, 999);\n}\n    \n    if (params.ruleInput) {\n        // Process address filter\n        const addressFilter = params.ruleInput.find(rule => rule.type === \"Address\");\n        if (addressFilter && addressFilter.filterValue) {\n            addressValue = addressFilter.filterValue\n                .filter(add => add.type === \"Village\")\n                .map(add => add.uuid);\n        }\n\n        // Process date filter\n        const rangeDateFilter = params.ruleInput.find(rule => \n            rule.type === \"Concept\" && \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.uuid === VISIT_DATE_CONCEPT_UUID\n        );\n        \n        if (rangeDateFilter && rangeDateFilter.filterValue) {\n            const minDateInput = new Date(rangeDateFilter.filterValue.minValue);\n            const maxDateInput = new Date(rangeDateFilter.filterValue.maxValue);\n            \n            if (!isNaN(minDateInput.getTime()) && !isNaN(maxDateInput.getTime())) {\n                minDateValue = new Date(minDateInput);\n                minDateValue.setHours(0, 0, 0, 0);\n                maxDateValue = new Date(maxDateInput);\n                maxDateValue.setHours(23, 59, 59, 999);\n            }\n        }\n        \n        // Process Anya Sthal filter\n        const anyaSthalFilter = params.ruleInput.find(rule => \n            rule.type === \"Concept\" && \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.uuid === ANYA_STHAL_CONCEPT_UUID\n        );\n        \n        if (anyaSthalFilter && anyaSthalFilter.filterValue && anyaSthalFilter.filterValue.length) {\n            anyaSthalValues = anyaSthalFilter.filterValue.map(item => item.uuid);\n        }\n        \n        // Process Campaign Name (Search) filter\n        const campaignNameSearchFilter = params.ruleInput.find(rule => \n            rule.type === \"Concept\" && \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.uuid === CAMPAIGN_NAME_SEARCH_CONCEPT_UUID\n        );\n        \n        if (campaignNameSearchFilter && campaignNameSearchFilter.filterValue && campaignNameSearchFilter.filterValue.length > 0) {\n           campaignNameSearch = campaignNameSearchFilter.filterValue;\n        }\n    }\n    \n    // Get filtered campaign UUIDs based on name search\n    let filteredCampaignUUIDs = [];\n    if (campaignNameSearch) {\n        const campaigns = params.db.objects('Individual').filtered(\n            \"voided = false AND subjectType.name = 'Campaign' AND firstName CONTAINS[c] $0\", \n            campaignNameSearch\n        );\n        filteredCampaignUUIDs = Array.from(campaigns).map(camp => camp.uuid);\n        \n        // If no campaigns match the search, return empty array immediately\n        if (filteredCampaignUUIDs.length === 0) {\n            return [];\n        }\n    }\n\n    // Build base query\n    let query = `voided = false AND subjectType.name = 'Outreach'`;\n    query += ` AND (createdByUUID == NULL OR createdByUUID != $0)`;\n    \n    // Get initial filtered individuals\n    let filteredIndividuals = Array.from(params.db.objects('Individual').filtered(query, userUUID));\n    \n    // Apply campaign name filter if search term exists\n    if (filteredCampaignUUIDs.length > 0) {\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            if (!Array.isArray(observations)) return false;\n            \n            const campaignObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === 'ebb78aa2-4634-4fec-84fe-e4fab2d833ad' &&\n                obs.valueJSON\n            );\n            \n            if (!campaignObs) return false;\n            \n            const valueJson = JSON.parse(campaignObs.valueJSON);\n            const campaignUuid = valueJson.value || valueJson.answer;\n            \n            return campaignUuid && filteredCampaignUUIDs.includes(campaignUuid);\n        });\n    }\n    \n    // Apply Anya Sthal filter if needed\n    if (anyaSthalValues.length > 0) {\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            if (!Array.isArray(observations)) return false;\n            \n            const anyaSthalObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === ANYA_STHAL_CONCEPT_UUID && \n                obs.valueJSON\n            );\n            \n            if (!anyaSthalObs) return false;\n            \n            const valueJson = JSON.parse(anyaSthalObs.valueJSON);\n            return anyaSthalValues.some(uuid => valueJson.answer === uuid);\n        });\n    }\n\n     // Add address filter if present\n     if (addressValue.length > 0) {\n        const output = addressValue.map(item => `'${item}'`).join(\", \");\n        query += ` AND lowestAddressLevel.uuid IN {${output}}`;\n\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            \n            if (!Array.isArray(observations)) {\n                return false;\n            }\n            \n            // Find the address details observation\n            const addressObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === ADDRESS_DETAILS_CONCEPT_UUID\n            );\n            \n            if (!addressObs) {\n                return false;\n            }\n            \n            // Try different ways to get the address value\n            let addressUuid = addressObs.value;\n            \n            if (!addressUuid && addressObs.valueJSON) {\n                const valueJson = JSON.parse(addressObs.valueJSON);\n                addressUuid = valueJson && valueJson.answer;\n            }\n            \n            if (!addressUuid && addressObs.observation) {\n                const obs = JSON.parse(addressObs.observation);\n                addressUuid = obs && obs.value;\n            }\n            \n            if (!addressUuid) {\n                return false;\n            }\n            \n            return addressValue.includes(addressUuid);\n        });\n    }\n    \n\n    // Apply date filter if needed\n    if (minDateValue && maxDateValue) {\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            if (!Array.isArray(observations)) return false;\n            \n            const visitDateObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === VISIT_DATE_CONCEPT_UUID && \n                obs.valueJSON\n            );\n            \n            if (!visitDateObs) return false;\n            \n            const valueJson = JSON.parse(visitDateObs.valueJSON);\n            const visitDate = new Date(valueJson.value || valueJson.answer);\n            \n            return !isNaN(visitDate.getTime()) && \n                   visitDate >= minDateValue && \n                   visitDate <= maxDateValue;\n        });\n    }\n\n    return filteredIndividuals;\n};",
  "description" : "",
  "color" : "#f8e781",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "9a91223d-0eef-4948-9f88-0b419a9c4dd1",
  "id" : 6748,
  "name" : "No. of Internal trainings-Catchment data",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n\n({ params, imports, db }) => {\n    const now = new Date();\n    const currentMonth = now.getMonth();\n    const currentYear = now.getFullYear();\n    const financialYearEnd = currentMonth < 3 ? currentYear - 1 : currentYear;\n    const financialYearStart = financialYearEnd - 1;\n    const minDate = new Date(financialYearStart, 3, 1);\n    const maxDate = new Date(financialYearEnd, 2, 31, 23, 59, 59, 999);\n\n    const encounters = params.db.objects('Encounter').filtered(`\n        voided = false \n        AND encounterType.name = \"Internal Training\"\n        AND cancelDateTime = NULL\n        AND encounterDateTime >= $0 \n        AND encounterDateTime <= $1\n    `, minDate, maxDate);\n\n    const individualMap = new Map();\n    \n    encounters.forEach(enc => {\n        if (enc.individual) {\n            individualMap.set(enc.individual.uuid, enc.individual);\n        }\n    });\n\n    const uniqueIndividuals = Array.from(individualMap.values());\n\n    return {\n        primaryValue: uniqueIndividuals.length,\n        lineListFunction: () => uniqueIndividuals\n    };\n};",
  "description" : "",
  "color" : "#ffbf00",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "2d3f0b8b-ba1b-4a75-8806-b973ffe7a1ea",
  "id" : 6751,
  "name" : "Outreach Client Registration Follow-Ups Due - Other Data",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({ params }) => {\n    const userUUID = params.user.userUUID;\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n    let anyaSthalValues = [];\n    const VISIT_DATE_CONCEPT_UUID = 'ff308558-e951-46bf-8115-c41bf16b02da';\n    const ANYA_STHAL_CONCEPT_UUID = 'd7d0afa3-3b73-4317-94fc-c7b43db62367';\n    const FOLLOW_UP_STATUS_CONCEPT_UUID = 'e26a61db-d7bf-4fbe-b5e2-ed60294e8f62';\n    const FOLLOW_UP_REQUIRED_UUID = '271a0678-be07-4802-b228-92e1cfd8c56e';\n\n    // Set default to previous financial year (April to March)\n    const now = new Date();\n    const currentYear = now.getFullYear();\n    const currentMonth = now.getMonth();\n    \n    // Default to previous financial year (April 1 to March 31)\n    if (currentMonth < 3) {\n        minDateValue = new Date(currentYear - 2, 3, 1, 0, 0, 0, 0);\n        maxDateValue = new Date(currentYear - 1, 2, 31, 23, 59, 59, 999);\n    } else {\n        minDateValue = new Date(currentYear - 1, 3, 1, 0, 0, 0, 0);\n        maxDateValue = new Date(currentYear, 2, 31, 23, 59, 59, 999);\n    }\n    \n    if (params.ruleInput) {\n        const addressFilter = params.ruleInput.find(rule => rule.type === \"Address\");\n        if (addressFilter && addressFilter.filterValue) {\n            addressValue = addressFilter.filterValue\n                .filter(add => add.type === \"Administrative Unit\")\n                .map(add => add.uuid);\n        }\n\n        // Process date filter\n        const rangeDateFilter = params.ruleInput.find(rule => \n            rule.type === \"Concept\" && \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.uuid === VISIT_DATE_CONCEPT_UUID\n        );\n        \n        if (rangeDateFilter && rangeDateFilter.filterValue) {\n            const minDateInput = new Date(rangeDateFilter.filterValue.minValue);\n            const maxDateInput = new Date(rangeDateFilter.filterValue.maxValue);\n            \n            if (!isNaN(minDateInput.getTime()) && !isNaN(maxDateInput.getTime())) {\n                minDateValue = new Date(minDateInput);\n                minDateValue.setHours(0, 0, 0, 0);\n                maxDateValue = new Date(maxDateInput);\n                maxDateValue.setHours(23, 59, 59, 999);\n            }\n        }\n        \n        // Process Anya Sthal filter\n        const anyaSthalFilter = params.ruleInput.find(rule => \n            rule.type === \"Concept\" && \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.uuid === ANYA_STHAL_CONCEPT_UUID\n        );\n        \n        if (anyaSthalFilter && anyaSthalFilter.filterValue && anyaSthalFilter.filterValue.length) {\n            anyaSthalValues = anyaSthalFilter.filterValue.map(item => item.uuid);\n        }\n    }\n\n\n    // Build base query\n    let query = `voided = false AND subjectType.name = 'Issues Identified'`;\n\n    // Add address filter if present\n    if (addressValue.length > 0) {\n        const output = addressValue.map(item => `'${item}'`).join(\", \");\n        query += ` AND lowestAddressLevel.uuid IN {${output}}`;\n    }\n    \n    // Add user filter\n    query += ` AND (createdByUUID == NULL OR createdByUUID != $0)`;\n\n    // Get initial filtered individuals\n    let filteredIndividuals = Array.from(params.db.objects('Individual').filtered(query, userUUID));\n    \n    // Apply Anya Sthal filter if needed\n    if (anyaSthalValues.length > 0) {\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            if (!Array.isArray(observations)) return false;\n            \n            const anyaSthalObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === ANYA_STHAL_CONCEPT_UUID && \n                obs.valueJSON\n            );\n            \n            if (!anyaSthalObs) return false;\n            \n            const valueJson = JSON.parse(anyaSthalObs.valueJSON);\n            return anyaSthalValues.some(uuid => valueJson.answer === uuid);\n        });\n    }\n    \n    // Apply follow-up status filter\n    filteredIndividuals = filteredIndividuals.filter(individual => {\n        const observations = individual.observations;\n        if (!Array.isArray(observations)) return false;\n        \n        const followUpObs = observations.find(obs => \n            obs.concept && \n            obs.concept.uuid === FOLLOW_UP_STATUS_CONCEPT_UUID && \n            obs.valueJSON && \n            obs.valueJSON.includes(FOLLOW_UP_REQUIRED_UUID)\n        );\n        \n        return !!followUpObs;\n    });\n\n    // Apply visit date filter\n    if (minDateValue && maxDateValue) {\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            if (!Array.isArray(observations)) return false;\n            \n            const visitDateObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === VISIT_DATE_CONCEPT_UUID && \n                obs.valueJSON\n            );\n            \n            if (!visitDateObs) return false;\n            \n            const valueJson = JSON.parse(visitDateObs.valueJSON);\n            const visitDate = new Date(valueJson.value || valueJson.answer);\n            return !isNaN(visitDate.getTime()) && \n                   visitDate >= minDateValue && \n                   visitDate <= maxDateValue;\n        });\n    }\n\n    return filteredIndividuals;\n};",
  "description" : "",
  "color" : "#ebe7f8",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "5908a1cd-7348-4778-a6ec-32e9dcb1e081",
  "id" : 6752,
  "name" : "No. of campaigns",
  "query" : "'use strict';\n\n({ params, imports }) => {\n    let userUUID = params.user.userUUID;\n    let today = new Date();\n    today.setHours(0, 0, 0, 0);\n\n    // Calculate previous financial year (April to March in India)\n    let currentMonth = today.getMonth(); // 0-11 (Jan = 0, Dec = 11)\n    let currentYear = today.getFullYear();\n    let previousFYStart, previousFYEnd;\n\n    if (currentMonth >= 3) { // April or later\n        previousFYStart = new Date(currentYear - 1, 3, 1); // 1st April of previous year\n        previousFYEnd = new Date(currentYear, 2, 31, 23, 59, 59, 999); // 31st March of current year\n    } else { // January to March\n        previousFYStart = new Date(currentYear - 2, 3, 1); // 1st April of year before last\n        previousFYEnd = new Date(currentYear - 1, 2, 31, 23, 59, 59, 999); // 31st March of last year\n    }\n\n    // Initialize query for Campaign subject type\n    let query = \"voided == false AND subjectType.name == 'Campaign'\";\n    let queryParams = [];\n\n    // Apply date filter for previous financial year\n    query += ` AND registrationDate >= $${queryParams.length} AND registrationDate <= $${queryParams.length + 1}`;\n    queryParams.push(previousFYStart, previousFYEnd);\n\n    // Get all campaigns from previous FY\n    let campaigns = params.db.objects(\"Individual\")\n        .filtered(query, ...queryParams);\n\n    return imports.lodash.uniqBy(campaigns, 'uuid');\n};",
  "description" : "",
  "color" : "#f8efe7",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "f8a88f9b-8f74-45d8-a8c0-19389cb7ad94",
  "id" : 6753,
  "name" : "Total active lit cases",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({params, imports}) => {\n    let UUIDs = params.user.userUUID;\n    \n    let natureOfCaseValue = [];\n    let applicantName = '';\n    let minDateValue = null;\n    let maxDateValue = null;\n    const NEXT_DATE_CONCEPT_UUID = 'cd8aa6fb-9277-47a5-b082-a70c76d3cc56';\n    \n    if (params.ruleInput) {\n        const conceptFilters = params.ruleInput.filter(rule => rule.type === \"Concept\");\n        \n        const natureOfCaseFilter = conceptFilters.find(rule => \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.name === 'Nature of Case'\n        );\n        if (natureOfCaseFilter && natureOfCaseFilter.filterValue) {\n            natureOfCaseValue = Array.isArray(natureOfCaseFilter.filterValue) \n                ? natureOfCaseFilter.filterValue.map(add => add.uuid || add)\n                : [natureOfCaseFilter.filterValue];\n        }\n        \n        const nameFilter = conceptFilters.find(rule => \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.name === 'Name of applicant'\n        );\n        if (nameFilter && nameFilter.filterValue) {\n            applicantName = nameFilter.filterValue;\n        }\n        \n        // Process Next Date filter\n        const nextDateFilter = params.ruleInput.find(rule => \n            rule.type === \"Concept\" && \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.uuid === NEXT_DATE_CONCEPT_UUID\n        );\n        \n        if (nextDateFilter && nextDateFilter.filterValue) {\n            const minDateInput = new Date(nextDateFilter.filterValue.minValue);\n            const maxDateInput = new Date(nextDateFilter.filterValue.maxValue);\n            \n            if (!isNaN(minDateInput.getTime()) && !isNaN(maxDateInput.getTime())) {\n                minDateValue = new Date(minDateInput);\n                minDateValue.setHours(0, 0, 0, 0);\n                maxDateValue = new Date(maxDateInput);\n                maxDateValue.setHours(23, 59, 59, 999);\n            }\n        }\n    }\n    \n    let query = `voided = false `;\n    \n    /*  252f4c55-d113-4951-8ebb-eed01b9ccbb9 ---> Nature of Case  \n        b1927aeb-ab4c-46a6-8eff-6ccdf38f5478 ---> Status of Case\n    */\n    \n    if (natureOfCaseValue.length > 0) {\n        let conditions = natureOfCaseValue.map(uuid => `$obs1.valueJSON CONTAINS '${uuid}'`).join(' OR ');\n        query += ` \n          AND SUBQUERY(observations, $obs1,\n            $obs1.concept.uuid = '252f4c55-d113-4951-8ebb-eed01b9ccbb9' \n            AND (${conditions})\n          ).@count > 0`;\n    }\n    \n    if (applicantName) {\n        query += `\n          AND SUBQUERY(individual.observations, $obs2,\n            $obs2.concept.uuid = 'a166f8fb-a245-4c2a-ad0b-a9eac2dc0b8d'\n            AND $obs2.valueJSON CONTAINS[c] '${applicantName}'\n          ).@count > 0`;\n    }\n    \n    let enrolments = params.db.objects(\"ProgramEnrolment\").filtered(`\n      program.name = 'Case Status' \n      AND voided = false\n      AND programExitDateTime = null \n      AND SUBQUERY(observations, $observation, \n            $observation.concept.uuid = 'b1927aeb-ab4c-46a6-8eff-6ccdf38f5478' AND \n            (\n                  $observation.valueJSON CONTAINS 'df2c6f91-cf67-494c-9e85-8816918f0fed' \n            )\n      ).@count > 0 AND (createdByUUID = NULL OR createdByUUID = $0) AND ${query}`, UUIDs);\n    \n    // Apply Next Date filter if date range is provided\n    if (minDateValue && maxDateValue) {\n        const minTime = minDateValue.getTime();\n        const maxTime = maxDateValue.getTime();\n        \n        enrolments = enrolments.filter(enrolment => {\n            const nextDateObs = enrolment.observations && enrolment.observations.find(obs => \n                obs && obs.concept && \n                obs.concept.uuid === NEXT_DATE_CONCEPT_UUID && \n                obs.valueJSON\n            );\n            \n            if (!nextDateObs) return false;\n            \n            const dateObj = JSON.parse(nextDateObs.valueJSON);\n            const dateValue = dateObj && dateObj.value;\n            if (!dateValue) return false;\n            \n            const date = new Date(dateValue).getTime();\n            if (isNaN(date)) return false;\n            \n            return date >= minTime && date <= maxTime;\n        });\n    }\n    \n    return enrolments.map((enrl) => enrl.individual);\n};",
  "description" : "",
  "color" : "#ebf8e7",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "7e942d91-7326-4b2b-bc81-7ff3c5e91779",
  "id" : 6755,
  "name" : "Outreach dummy (voided~4755)",
  "query" : "//// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({ params, imports }) => {\n    console.log('=== RULE STARTED ===');\n    console.log('Initial params.ruleInput:', JSON.stringify(params.ruleInput, null, 2));\n    let userUUID = params.user.userUUID;\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n    let anyaSthalValues = [];\n    const VISIT_DATE_CONCEPT_UUID = 'ff308558-e951-46bf-8115-c41bf16b02da';\n    const ANYA_STHAL_CONCEPT_UUID = 'd7d0afa3-3b73-4317-94fc-c7b43db62367';\n    const ADDRESS_DETAILS_CONCEPT_UUID = '35a98d23-f999-4367-976a-22682122901d'; // Address Details - Village\n\n    // Set default to previous financial year (April to March)\n    const now = new Date();\n    const currentYear = now.getFullYear();\n    const currentMonth = now.getMonth();\n    \n    // Default to previous financial year (April 1 to March 31)\n    if (currentMonth < 3) {\n        minDateValue = new Date(currentYear - 2, 3, 1, 0, 0, 0, 0);\n        maxDateValue = new Date(currentYear - 1, 2, 31, 23, 59, 59, 999);\n    } else {\n        minDateValue = new Date(currentYear - 1, 3, 1, 0, 0, 0, 0);\n        maxDateValue = new Date(currentYear, 2, 31, 23, 59, 59, 999);\n    }\n    \n    if (params.ruleInput && Array.isArray(params.ruleInput)) {\n        // Process address filter - minimal approach\n        for (let i = 0; i < params.ruleInput.length; i++) {\n            const rule = params.ruleInput[i];\n            if (!rule || rule.type !== \"Concept\") continue;\n            \n            // Check if this is our address filter\n            const concept = rule.observationBasedFilter && rule.observationBasedFilter.concept;\n            if (!concept || concept.name !== \"Address Details - Village\") continue;\n            \n            // Safely get filter value\n            const filterValue = rule.filterValue;\n            if (!filterValue) continue;\n            \n            // Ensure we have an array to work with\n            const values = Array.isArray(filterValue) ? filterValue : [filterValue];\n            \n            // Extract UUIDs safely\n            for (let j = 0; j < values.length; j++) {\n                const val = values[j];\n                if (val && val.uuid && !addressValue.includes(val.uuid)) {\n                    addressValue.push(val.uuid);\n                }\n            }\n            break;\n        }\n    }\n\n    if (params.ruleInput && Array.isArray(params.ruleInput)) {\n        // Process date filter\n        const rangeDateFilter = params.ruleInput.find(rule => \n            rule && \n            rule.type === \"Concept\" && \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.uuid === VISIT_DATE_CONCEPT_UUID\n        );\n        \n        if (rangeDateFilter && rangeDateFilter.filterValue) {\n            const minDateInput = new Date(rangeDateFilter.filterValue.minValue);\n            const maxDateInput = new Date(rangeDateFilter.filterValue.maxValue);\n            \n            if (!isNaN(minDateInput.getTime()) && !isNaN(maxDateInput.getTime())) {\n                minDateValue = new Date(minDateInput);\n                minDateValue.setHours(0, 0, 0, 0);\n                maxDateValue = new Date(maxDateInput);\n                maxDateValue.setHours(23, 59, 59, 999);\n            }\n        }\n        \n        // Process Anya Sthal filter\n        const anyaSthalFilter = params.ruleInput.find(rule => \n            rule && \n            rule.type === \"Concept\" && \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.uuid === ANYA_STHAL_CONCEPT_UUID\n        );\n        \n        if (anyaSthalFilter && anyaSthalFilter.filterValue) {\n            anyaSthalValues = [];\n            const filterValue = anyaSthalFilter.filterValue;\n            const values = Array.isArray(filterValue) ? filterValue : [filterValue];\n            \n            for (let i = 0; i < values.length; i++) {\n                const val = values[i];\n                if (val && val.uuid) {\n                    anyaSthalValues.push(val.uuid);\n                }\n            }\n        }\n    }\n\n    // Build base query\n    let query = `voided = false AND subjectType.name = 'Outreach'`;\n\n   \n    // Add user filter\n    query += ` AND (createdByUUID == NULL OR createdByUUID = $0)`;\n\n    // Get initial filtered individuals\n    let filteredIndividuals = Array.from(params.db.objects('Individual').filtered(query, userUUID));\n    \n    // Apply Anya Sthal filter if needed\n    if (anyaSthalValues.length > 0) {\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            if (!Array.isArray(observations)) return false;\n            \n            const anyaSthalObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === ANYA_STHAL_CONCEPT_UUID && \n                obs.valueJSON\n            );\n            \n            if (!anyaSthalObs) return false;\n            \n            const valueJson = JSON.parse(anyaSthalObs.valueJSON);\n            return anyaSthalValues.some(uuid => valueJson.answer === uuid);\n        });\n    }\n\n     // Add address filter if present\n     if (addressValue.length > 0) {\n        const output = addressValue.map(item => `'${item}'`).join(\", \");\n        query += ` AND lowestAddressLevel.uuid IN {${output}}`;\n\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            \n            if (!Array.isArray(observations)) {\n                return false;\n            }\n            \n            // Find the address details observation\n            const addressObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === ADDRESS_DETAILS_CONCEPT_UUID\n            );\n            \n            if (!addressObs) {\n                return false;\n            }\n            \n            // Try different ways to get the address value\n            let addressUuid = addressObs.value;\n            \n            if (!addressUuid && addressObs.valueJSON) {\n                const valueJson = JSON.parse(addressObs.valueJSON);\n                addressUuid = valueJson && valueJson.answer;\n            }\n            \n            if (!addressUuid && addressObs.observation) {\n                const obs = JSON.parse(addressObs.observation);\n                addressUuid = obs && obs.value;\n            }\n            \n            if (!addressUuid) {\n                return false;\n            }\n            \n            return addressValue.includes(addressUuid);\n        });\n    }\n    \n\n    // Apply date filter if needed\n    if (minDateValue && maxDateValue) {\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            if (!Array.isArray(observations)) return false;\n            \n            const visitDateObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === VISIT_DATE_CONCEPT_UUID && \n                obs.valueJSON\n            );\n            \n            if (!visitDateObs) return false;\n            \n            const valueJson = JSON.parse(visitDateObs.valueJSON);\n            const visitDate = new Date(valueJson.value || valueJson.answer);\n            \n            return !isNaN(visitDate.getTime()) && \n                   visitDate >= minDateValue && \n                   visitDate <= maxDateValue;\n        });\n    }\n\n    return filteredIndividuals;\n};\n\n",
  "description" : "",
  "color" : "#ff0000",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : true
}, {
  "uuid" : "b3c317b9-d433-456f-8e72-8cb47f4cd658",
  "id" : 6750,
  "name" : "All outreach visits this year",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({ params, imports }) => {\n    let userUUID = params.user.userUUID;\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n    let anyaSthalValues = [];\n    let campaignNameSearch = '';\n    const VISIT_DATE_CONCEPT_UUID = 'ff308558-e951-46bf-8115-c41bf16b02da';\n    const ANYA_STHAL_CONCEPT_UUID = 'd7d0afa3-3b73-4317-94fc-c7b43db62367';\n    const CAMPAIGN_NAME_SEARCH_CONCEPT_UUID = 'e17aba43-433c-43c0-a7e7-d7f5a79ed244';\n    const ADDRESS_DETAILS_CONCEPT_UUID = '35a98d23-f999-4367-976a-22682122901d'; // Address Details - Village\n\n    // Set default to previous financial year (April to March)\n    const now = new Date();\n    const currentYear = now.getFullYear();\n    const currentMonth = now.getMonth();\n    \n    // Default to previous financial year (April 1 to March 31)\nif (currentMonth >= 4) {\n    minDateValue = new Date(currentYear, 3, 1, 0, 0, 0, 0);\n    maxDateValue = new Date(currentYear + 1, 3, 0, 23, 59, 59, 999);\n} else {\n    minDateValue = new Date(currentYear - 1, 3, 1, 0, 0, 0, 0);\n    maxDateValue = new Date(currentYear, 3, 0, 23, 59, 59, 999);\n}\n    \n    if (params.ruleInput) {\n        // Process address filter\n        const addressFilter = params.ruleInput.find(rule => rule.type === \"Address\");\n        if (addressFilter && addressFilter.filterValue) {\n            addressValue = addressFilter.filterValue\n                .filter(add => add.type === \"Village\")\n                .map(add => add.uuid);\n        }\n\n        // Process date filter\n        const rangeDateFilter = params.ruleInput.find(rule => \n            rule.type === \"Concept\" && \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.uuid === VISIT_DATE_CONCEPT_UUID\n        );\n        \n        if (rangeDateFilter && rangeDateFilter.filterValue) {\n            const minDateInput = new Date(rangeDateFilter.filterValue.minValue);\n            const maxDateInput = new Date(rangeDateFilter.filterValue.maxValue);\n            \n            if (!isNaN(minDateInput.getTime()) && !isNaN(maxDateInput.getTime())) {\n                minDateValue = new Date(minDateInput);\n                minDateValue.setHours(0, 0, 0, 0);\n                maxDateValue = new Date(maxDateInput);\n                maxDateValue.setHours(23, 59, 59, 999);\n            }\n        }\n        \n        // Process Anya Sthal filter\n        const anyaSthalFilter = params.ruleInput.find(rule => \n            rule.type === \"Concept\" && \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.uuid === ANYA_STHAL_CONCEPT_UUID\n        );\n        \n        if (anyaSthalFilter && anyaSthalFilter.filterValue && anyaSthalFilter.filterValue.length) {\n            anyaSthalValues = anyaSthalFilter.filterValue.map(item => item.uuid);\n        }\n        \n        // Process Campaign Name (Search) filter\n        const campaignNameSearchFilter = params.ruleInput.find(rule => \n            rule.type === \"Concept\" && \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.uuid === CAMPAIGN_NAME_SEARCH_CONCEPT_UUID\n        );\n        \n        if (campaignNameSearchFilter && campaignNameSearchFilter.filterValue && campaignNameSearchFilter.filterValue.length > 0) {\n           campaignNameSearch = campaignNameSearchFilter.filterValue;\n        }\n    }\n\n    // Get filtered campaign UUIDs based on name search\n    let filteredCampaignUUIDs = [];\n    if (campaignNameSearch) {\n        const campaigns = params.db.objects('Individual').filtered(\n            \"voided = false AND subjectType.name = 'Campaign' AND firstName CONTAINS[c] $0\", \n            campaignNameSearch\n        );\n        filteredCampaignUUIDs = Array.from(campaigns).map(camp => camp.uuid);\n        \n        // If no campaigns match the search, return empty array immediately\n        if (filteredCampaignUUIDs.length === 0) {\n            return [];\n        }\n    }\n\n    // Build base query\n    let query = `voided = false AND subjectType.name = 'Outreach'`;\n    \n    // Add user filter\n    query += ` AND (createdByUUID == NULL OR createdByUUID = $0)`;\n\n    // Get initial filtered individuals\n    let filteredIndividuals = Array.from(params.db.objects('Individual').filtered(query, userUUID));\n    \n    // Apply campaign name filter if search term exists\n    if (filteredCampaignUUIDs.length > 0) {\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            if (!Array.isArray(observations)) return false;\n            \n            const campaignObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === 'ebb78aa2-4634-4fec-84fe-e4fab2d833ad' &&\n                obs.valueJSON\n            );\n            \n            if (!campaignObs) return false;\n            \n            const valueJson = JSON.parse(campaignObs.valueJSON);\n            const campaignUuid = valueJson.value || valueJson.answer;\n            \n            return campaignUuid && filteredCampaignUUIDs.includes(campaignUuid);\n        });\n    }\n    \n    // Apply Anya Sthal filter if needed\n    if (anyaSthalValues.length > 0) {\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            if (!Array.isArray(observations)) return false;\n            \n            const anyaSthalObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === ANYA_STHAL_CONCEPT_UUID && \n                obs.valueJSON\n            );\n            \n            if (!anyaSthalObs) return false;\n            \n            const valueJson = JSON.parse(anyaSthalObs.valueJSON);\n            return anyaSthalValues.some(uuid => valueJson.answer === uuid);\n        });\n    }\n\n     // Add address filter if present\n     if (addressValue.length > 0) {\n        const output = addressValue.map(item => `'${item}'`).join(\", \");\n        query += ` AND lowestAddressLevel.uuid IN {${output}}`;\n\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            \n            if (!Array.isArray(observations)) {\n                return false;\n            }\n            \n            // Find the address details observation\n            const addressObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === ADDRESS_DETAILS_CONCEPT_UUID\n            );\n            \n            if (!addressObs) {\n                return false;\n            }\n            \n            // Try different ways to get the address value\n            let addressUuid = addressObs.value;\n            \n            if (!addressUuid && addressObs.valueJSON) {\n                const valueJson = JSON.parse(addressObs.valueJSON);\n                addressUuid = valueJson && valueJson.answer;\n            }\n            \n            if (!addressUuid && addressObs.observation) {\n                const obs = JSON.parse(addressObs.observation);\n                addressUuid = obs && obs.value;\n            }\n            \n            if (!addressUuid) {\n                return false;\n            }\n            \n            return addressValue.includes(addressUuid);\n        });\n    }\n    \n\n    // Apply date filter if needed\n    if (minDateValue && maxDateValue) {\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            if (!Array.isArray(observations)) return false;\n            \n            const visitDateObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === VISIT_DATE_CONCEPT_UUID && \n                obs.valueJSON\n            );\n            \n            if (!visitDateObs) return false;\n            \n            const valueJson = JSON.parse(visitDateObs.valueJSON);\n            const visitDate = new Date(valueJson.value || valueJson.answer);\n            \n            return !isNaN(visitDate.getTime()) && \n                   visitDate >= minDateValue && \n                   visitDate <= maxDateValue;\n        });\n    }\n\n    return filteredIndividuals;\n};",
  "description" : "",
  "color" : "#f8f7e7",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "0a63043a-44ce-4df4-ad1b-34c6d2105ab0",
  "id" : 6754,
  "name" : "Total issues identified from outreach requiring follow up",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({ params }) => {\n    const userUUID = params.user.userUUID;\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n    let anyaSthalValues = [];\n    const VISIT_DATE_CONCEPT_UUID = 'ff308558-e951-46bf-8115-c41bf16b02da';\n    const ANYA_STHAL_CONCEPT_UUID = 'd7d0afa3-3b73-4317-94fc-c7b43db62367';\n    const FOLLOW_UP_STATUS_CONCEPT_UUID = 'e26a61db-d7bf-4fbe-b5e2-ed60294e8f62';\n    const FOLLOW_UP_REQUIRED_UUID = '271a0678-be07-4802-b228-92e1cfd8c56e';\n    const ADDRESS_DETAILS_CONCEPT_UUID = '3e2e3130-6dfe-435d-a7e3-76d5999e28e3'; // Address Details - Village\n\n    // Set default to previous financial year (April to March)\n    const now = new Date();\n    const currentYear = now.getFullYear();\n    const currentMonth = now.getMonth();\n    \n    // Default to previous financial year (April 1 to March 31)\nif (currentMonth >= 4) {\n    minDateValue = new Date(currentYear, 3, 1, 0, 0, 0, 0);\n    maxDateValue = new Date(currentYear + 1, 3, 0, 23, 59, 59, 999);\n} else {\n    minDateValue = new Date(currentYear - 1, 3, 1, 0, 0, 0, 0);\n    maxDateValue = new Date(currentYear, 3, 0, 23, 59, 59, 999);\n}\n    \n    if (params.ruleInput) {\n        // Process address filter\n        const addressFilter = params.ruleInput.find(rule => rule.type === \"Address\");\n        if (addressFilter && addressFilter.filterValue) {\n            addressValue = addressFilter.filterValue\n                .filter(add => add.type === \"Village\");\n        }\n\n        // Process date filter\n        const rangeDateFilter = params.ruleInput.find(rule => \n            rule.type === \"Concept\" && \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.uuid === VISIT_DATE_CONCEPT_UUID\n        );\n        \n        if (rangeDateFilter && rangeDateFilter.filterValue) {\n            const minDateInput = new Date(rangeDateFilter.filterValue.minValue);\n            const maxDateInput = new Date(rangeDateFilter.filterValue.maxValue);\n            \n            if (!isNaN(minDateInput.getTime()) && !isNaN(maxDateInput.getTime())) {\n                minDateValue = new Date(minDateInput);\n                minDateValue.setHours(0, 0, 0, 0);\n                maxDateValue = new Date(maxDateInput);\n                maxDateValue.setHours(23, 59, 59, 999);\n            }\n        }\n        \n        // Process Anya Sthal filter\n        const anyaSthalFilter = params.ruleInput.find(rule => \n            rule.type === \"Concept\" && \n            rule.observationBasedFilter && \n            rule.observationBasedFilter.concept && \n            rule.observationBasedFilter.concept.uuid === ANYA_STHAL_CONCEPT_UUID\n        );\n        \n        if (anyaSthalFilter && anyaSthalFilter.filterValue && anyaSthalFilter.filterValue.length) {\n            anyaSthalValues = anyaSthalFilter.filterValue.map(item => item.uuid);\n        }\n    }\n\n    // Build base query\n    let query = `voided = false AND subjectType.name = 'Issues Identified'`;\n\n    // Add user filter\n    query += ` AND (createdByUUID == NULL OR createdByUUID = $0)`;\n\n    // Get initial filtered individuals\n    let filteredIndividuals = Array.from(params.db.objects('Individual').filtered(query, userUUID));\n    \n    // Apply Anya Sthal filter if needed\n    if (anyaSthalValues.length > 0) {\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            if (!Array.isArray(observations)) return false;\n            \n            const anyaSthalObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === ANYA_STHAL_CONCEPT_UUID && \n                obs.valueJSON\n            );\n            \n            if (!anyaSthalObs) return false;\n            \n            const valueJson = JSON.parse(anyaSthalObs.valueJSON);\n            return anyaSthalValues.some(uuid => valueJson.answer === uuid);\n        });\n    }\n\n    // Add address filter if present\n    if (addressValue.length > 0) {\n        console.log('Filtering by villages:', addressValue);\n        \n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            if (!Array.isArray(observations)) {\n                console.log('No observations array for individual:', individual.uuid);\n                return false;\n            }\n\n            \n            // Find the address details observation\n            const addressObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === ADDRESS_DETAILS_CONCEPT_UUID\n            );\n            \n            if (!addressObs) {\n                console.log('No address observation found for individual:', individual.uuid);\n                return false;\n            }\n            console.log('Found address observation for individual:', individual.uuid, addressObs);\n            \n            // Try different ways to get the address value\n            let addressUuid = addressObs.value;\n            \n            if (!addressUuid && addressObs.valueJSON) {\n                const valueJson = JSON.parse(addressObs.valueJSON);\n                addressUuid = valueJson && valueJson.answer;\n            }\n            \n            if (!addressUuid && addressObs.observation) {\n                const obs = JSON.parse(addressObs.observation);\n                addressUuid = obs && obs.value;\n            }\n            \n            if (!addressUuid) {\n                console.log('No address UUID found in observation for individual:', individual.uuid);\n                return false;\n            }\n            console.log('Extracted address UUID:', addressUuid, 'for individual:', individual.uuid);\n            \n            // Update the address filter to handle village name comparison with observation JSON\n            const addressName = addressObs.valueJSON && JSON.parse(addressObs.valueJSON).answer;\n            return addressValue.some(add => add.name === addressName);\n        });\n    }\n    \n    // Apply follow-up status filter\n    filteredIndividuals = filteredIndividuals.filter(individual => {\n        const observations = individual.observations;\n        if (!Array.isArray(observations)) return false;\n        \n        const followUpObs = observations.find(obs => \n            obs.concept && \n            obs.concept.uuid === FOLLOW_UP_STATUS_CONCEPT_UUID && \n            obs.valueJSON && \n            obs.valueJSON.includes(FOLLOW_UP_REQUIRED_UUID)\n        );\n        \n        return !!followUpObs;\n    });\n\n    // Apply visit date filter\n    if (minDateValue && maxDateValue) {\n        filteredIndividuals = filteredIndividuals.filter(individual => {\n            const observations = individual.observations;\n            if (!Array.isArray(observations)) return false;\n            \n            const visitDateObs = observations.find(obs => \n                obs.concept && \n                obs.concept.uuid === VISIT_DATE_CONCEPT_UUID && \n                obs.valueJSON\n            );\n            \n            if (!visitDateObs) return false;\n            \n            const valueJson = JSON.parse(visitDateObs.valueJSON);\n            const visitDate = new Date(valueJson.value || valueJson.answer);\n            return !isNaN(visitDate.getTime()) && \n                   visitDate >= minDateValue && \n                   visitDate <= maxDateValue;\n        });\n    }\n\n    return filteredIndividuals;\n};\n",
  "description" : "",
  "color" : "#ebe7f8",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "b1c9b90f-5e1b-45c2-b043-86945e4a13ab",
  "id" : 6756,
  "name" : "Influencing State—No. of engagements",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n\n({ params, imports, db }) => {\n    const now = new Date();\n    const currentMonth = now.getMonth();\n    const currentYear = now.getFullYear();\n    const financialYearEnd = currentMonth < 3 ? currentYear - 1 : currentYear;\n    const financialYearStart = financialYearEnd - 1;\n    const minDate = new Date(financialYearStart, 3, 1);\n    const maxDate = new Date(financialYearEnd, 2, 31, 23, 59, 59, 999);\n\n    const influencingStateList = params.db.objects('Individual').filtered(`\n        voided = false \n        AND subjectType.name = 'Influencing State'\n        AND registrationDate >= $0\n        AND registrationDate <= $1\n    `, minDate, maxDate);\n\n    return influencingStateList;\n};",
  "description" : "",
  "color" : "#e6eefa",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
}, {
  "uuid" : "53464f4b-9022-4f56-9aa0-01ce85ad1339",
  "id" : 6749,
  "name" : "Total claims registered this year- Other Field workers",
  "query" : "// Documentation - https://docs.mongodb.com/realm-legacy/docs/javascript/latest/index.html#queries\n'use strict';\n({ params, imports }) => {\n    let userUUID = params.user.userUUID;\n    let addressValue = [];\n    let minDateValue = null;\n    let maxDateValue = null;\n\n    if (params.ruleInput) {\n        let addressFilter = params.ruleInput.filter(rule => rule.type == \"Address\");\n        if (addressFilter.length > 0 && addressFilter[0].filterValue) {\n            addressValue = addressFilter[0].filterValue\n                .filter(add => add.type == \"Administrative Unit\")\n                .map(add => add.uuid);\n        }\n\n        let rangeDateFilter = params.ruleInput.filter(rule => rule.type == \"RegistrationDate\");\n        if (rangeDateFilter.length > 0 && rangeDateFilter[0].filterValue) {\n            let minDateInput = new Date(rangeDateFilter[0].filterValue.minValue);\n            let maxDateInput = new Date(rangeDateFilter[0].filterValue.maxValue);\n            \n            minDateValue = new Date(minDateInput.getFullYear(), minDateInput.getMonth(), minDateInput.getDate(), 0, 0, 0, 0);\n            maxDateValue = new Date(maxDateInput.getFullYear(), maxDateInput.getMonth(), maxDateInput.getDate(), 23, 59, 59, 999);\n        }\n    }\n\n    if (!minDateValue || !maxDateValue) {\n        const currentDate = new Date();\n        const currentYear = currentDate.getFullYear();\n        const currentMonth = currentDate.getMonth() + 1;\n        \nif (currentMonth >= 4) {\n    minDateValue = new Date(currentYear, 3, 1, 0, 0, 0, 0);\n    maxDateValue = new Date(currentYear + 1, 3, 0, 23, 59, 59, 999);\n} else {\n    minDateValue = new Date(currentYear - 1, 3, 1, 0, 0, 0, 0);\n    maxDateValue = new Date(currentYear, 3, 0, 23, 59, 59, 999);\n}\n    }\n\n    let query = `voided = false AND subjectType.name = 'Claim'`;\n\n    if (addressValue.length > 0) {\n        let output = addressValue.map(item => `'${item}'`).join(\", \");\n        query += ` AND lowestAddressLevel.uuid IN {${output}}`;\n    }\n\n    query += ` AND registrationDate >= $1 AND registrationDate <= $2`;\n    query += ` AND (createdByUUID == NULL OR createdByUUID != $0)`;\n\n    return params.db.objects('Individual')\n        .filtered(query, userUUID, minDateValue, maxDateValue);\n};",
  "description" : "",
  "color" : "#f8f7e7",
  "nested" : false,
  "count" : 1,
  "standardReportCardInputSubjectTypes" : [ ],
  "standardReportCardInputPrograms" : [ ],
  "standardReportCardInputEncounterTypes" : [ ],
  "voided" : false
} ]